<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<title>ì •ë ¬ ìƒ‰ì¸ ì‹¤í—˜</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<!-- í”„ë¦¬í…ë‹¤ë“œ í°íŠ¸ (CDN) -->
<link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard-dynamic-subset.css" />

<style>
:root{
  --bg: #F8FAFC;
  --card: #ffffff;
  --text: #1e293b; 
  --muted: #64748b;
  --border: #e2e8f0;
  
  --primary: #10B981;
  --primary-dark: #059669;
  --primary-light: #34D399;
  --accent: #d1fae5;
  
  --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  --shadow-lg: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
  
  --radius: 16px;
  --radius-sm: 8px;
}

*{ box-sizing:border-box; }
html, body{ height:100%; }

body{
  margin:0;
  padding:20px;
  background: var(--bg);
  font-family: "Pretendard", -apple-system, BlinkMacSystemFont, system-ui, Roboto, sans-serif;
  color: var(--text);
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
}

/* ë°°ê²½ ì¥ì‹ */
body::before {
  content:"";
  position: fixed;
  top: -50%; left: -50%;
  width: 200%; height: 200%;
  background: 
    radial-gradient(circle at 50% 50%, rgba(16, 185, 129, 0.03), transparent 60%),
    radial-gradient(circle at 80% 20%, rgba(52, 211, 153, 0.04), transparent 50%);
  z-index: -1;
  pointer-events: none;
}

.card{
  width: 100%;
  height: auto;
  background: var(--card);
  display: flex;
  flex-direction: column;
  position: relative;
  box-shadow: var(--shadow-lg);
  transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

@media (min-width: 1024px) {
  body { padding: 40px 20px; overflow: auto; align-items: center; }
  .card {
    max-width: 800px;
    height: auto;
    min-height: 600px;
    border-radius: var(--radius);
    border: 1px solid var(--border);
    transform: scale(1.2);
    transform-origin: center;
  }
  
  /* ê²Œì„ ì§„í–‰ ì¤‘ ì¹´ë“œ í¬ê¸° ì¶•ì†Œ (ë°ìŠ¤í¬íƒ‘ë§Œ) */
  .card.game-active {
    transform: scale(0.8);
    transform-origin: top center;
  }
}

/* ê²Œì„ í™œì„±í™” ì‹œ ìƒë‹¨ ì •ë ¬ ë° ì ì ˆí•œ ì—¬ë°± */
/* ê²Œì„ í™œì„±í™” ì‹œ ìƒë‹¨ ì •ë ¬ ë° ì ì ˆí•œ ì—¬ë°± */
body:has(.card.game-active) {
  align-items: flex-start;
  padding: 16px 0;
}

/* í—¤ë” ì˜ì—­ */
.header{
  padding: 16px;
  background: white;
  border-bottom: 1px solid var(--border);
  border-radius: var(--radius) var(--radius) 0 0;
  flex-shrink: 0;
}

@media (min-width: 1024px) {
  .header { padding: 24px; }
}



.headerTop{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:8px; /* ê°„ê²© ì¶•ì†Œ (16px -> 8px) */
  margin-bottom: 16px;
  min-height: 48px; 
}

.titleBox{ display:flex; flex-direction:column; gap:4px; flex-shrink: 1; min-width: 0; }
.title{ 
  font-weight: 800; 
  font-size: 19px; /* ì†Œí­ ì¶•ì†Œ */
  color: var(--text);
  letter-spacing: -0.02em;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

@media (min-width: 1024px) {
  .title { font-size: 24px; }
}
.sub{ 
  font-size: 14px; 
  color: var(--muted); 
  font-weight: 500;
}

/* ë­í‚¹ ë²„íŠ¼ (ëŒ€ê¸° ì¤‘ í‘œì‹œ) */
.ranking-btn-area {
  display: none; /* Default hidden */
  gap: 10px;
  margin-top: 20px;
}
.ranking-btn-area.active {
  display: flex !important; /* Show only when active */
}

.rank-open-btn {
  background: white;
  border: 1px solid var(--border);
  color: var(--text);
  padding: 8px 12px; /* íŒ¨ë”© ì¶•ì†Œ */
  border-radius: 999px;
  font-size: 13px; /* ì†Œí­ ì¶•ì†Œ */
  font-weight: 700;
  flex-shrink: 0; /* ë²„íŠ¼ì´ ì°Œê·¸ëŸ¬ì§€ì§€ ì•Šê²Œ */
  white-space: nowrap;
  box-shadow: var(--shadow-sm);
  display: flex; align-items: center; gap: 6px;
  transition: all 0.2s;
}
.rank-open-btn:hover {
  background: #f8fafc;
  transform: translateY(-2px);
  box-shadow: var(--shadow);
  color: var(--primary-dark);
  border-color: var(--primary-light);
}

/* ê²Œì„ ìƒíƒœ (ì§„í–‰ ì¤‘ì—ë§Œ í‘œì‹œ) */
.game-status-panel {
  display: none; /* JS Toggle */
  flex-direction: column;
  gap: 16px;
  width: 100%;
}
.game-status-panel.active { display: flex; }

.statusGroup{
  display: flex;
  gap: 8px;
  align-items: center;
  justify-content: flex-end;
}

.badge{
  font-size: 13px;
  padding: 6px 12px;
  border-radius: 999px;
  font-weight: 600;
  letter-spacing: -0.01em;
  background: var(--bg);
  color: var(--muted);
  border: 1px solid var(--border);
}
.badge.run{ background: #ecfdf5; color: #047857; border-color: #a7f3d0; }
.badge.done{ background: #f0fdf4; color: #15803d; border-color: #bbf7d0; }

.timerBadge{
  font-family: "Pretendard", monospace; 
  font-size: 20px;
  font-weight: 700;
  color: var(--primary-dark);
}

/* ì§„í–‰ë„ Bar */
.progress-area {
  display: flex;
  flex-direction: column;
  gap: 6px;
}
.progress-label {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  font-weight: 600;
  color: var(--muted);
}
.gaugeWrap{
  height: 8px;
  border-radius: 999px;
  background: #f1f5f9;
  overflow:hidden;
}
.gaugeBar{
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, var(--primary-light), var(--primary));
  transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: 0 0 10px rgba(16, 185, 129, 0.3);
}

/* 
  [Desktop HUD] 
  ë°ìŠ¤í¬íƒ‘ì—ì„œ í™”ë©´ ìƒë‹¨ì— ê³ ì •ë˜ëŠ” ë¯¸ë‹ˆ ìƒíƒœë°”
  - ìŠ¤í¬ë¡¤ê³¼ ë¬´ê´€í•˜ê²Œ 'ê²Œì„ ì¤‘'ì´ë©´ í•­ìƒ í‘œì‹œ
*/
.hud-pill {
  position: fixed;
  top: 14px;
  left: 50%;
  transform: translateX(-50%);
  display: none; 
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  padding: 8px 18px;
  border-radius: 999px;
  box-shadow: 0 8px 25px rgba(0,0,0,0.12);
  z-index: 10001;
  border: 1px solid var(--border);
  align-items: center;
  gap: 12px;
  transition: opacity 0.3s, transform 0.3s;
  white-space: nowrap;
  width: max-content;
  max-width: 95vw;
  flex-wrap: nowrap;
}
.hud-pill.visible {
  display: flex;
}

.hud-item {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 14px;
  font-weight: 600;
  color: var(--text);
  user-select: none;
}
.hud-val {
  font-family: "Pretendard", monospace;
  color: var(--primary-dark);
  font-weight: 700;
  font-size: 16px;
  min-width: 45px; 
  text-align: right;
}
.hud-sep {
  width: 1px; height: 14px; background: var(--border);
}

/* HUD Toggle Switch */
.hud-toggle-container {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  font-weight: 600;
  color: var(--muted);
  white-space: nowrap;
}
.switch {
  position: relative;
  display: inline-block;
  width: 34px;
  height: 20px;
}
.switch input { opacity: 0; width: 0; height: 0; }
.slider {
  position: absolute;
  cursor: pointer;
  top: 0; left: 0; right: 0; bottom: 0;
  background-color: #e2e8f0;
  transition: .3s;
  border-radius: 34px;
}
.slider:before {
  position: absolute;
  content: "";
  height: 14px; width: 14px;
  left: 3px; bottom: 3px;
  background-color: white;
  transition: .3s;
  border-radius: 50%;
}
input:checked + .slider { background-color: var(--primary); }
input:checked + .slider:before { transform: translateX(14px); }


/* ì»¨íŠ¸ë¡¤ ì˜ì—­ */
.controls{
  padding: 16px 24px;
  display:flex;
  gap:12px;
  flex-wrap:wrap;
  align-items:center;
  background: #f8fafc;
  border-bottom: 1px solid var(--border);
  transition: opacity 0.3s, max-height 0.3s;
  max-height: 200px;
  overflow: hidden;
}

/* ê²Œì„ ì§„í–‰ ì¤‘ controls ìˆ¨ê¸°ê¸° */
.card.game-active .controls {
  opacity: 0;
  max-height: 0;
  padding: 0;
  border: none;
}

/* í”Œë¡œíŒ… ì´ˆê¸°í™” ë²„íŠ¼ */
.floating-reset-btn {
  position: fixed;
  bottom: 30px;
  right: 30px;
  z-index: 10000;
  box-shadow: 0 8px 20px rgba(0,0,0,0.2);
  font-size: 15px;
  padding: 12px 24px;
}
.floating-reset-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 12px 30px rgba(0,0,0,0.3);
}

/* í”Œë¡œíŒ… ë¡œê·¸ ë‹¤ìš´ë¡œë“œ ë²„íŠ¼ */
.floating-log-btn {
  position: fixed;
  bottom: 90px;
  right: 30px;
  z-index: 10000;
  box-shadow: 0 8px 20px rgba(37, 99, 235, 0.3);
  font-size: 15px;
  padding: 12px 24px;
}
.floating-log-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 12px 30px rgba(37, 99, 235, 0.4);
}

.select-wrapper { position: relative; }
select{
  appearance: none;
  background: white;
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 10px 32px 10px 14px;
  font-family: inherit;
  font-weight: 600;
  font-size: 14px;
  color: var(--text);
  cursor: pointer;
  transition: all 0.2s;
}
select:hover { border-color: var(--primary); }
select:focus { outline:none; border-color: var(--primary); box-shadow: 0 0 0 3px var(--accent); }
.select-caret {
  position: absolute; right: 12px; top: 50%; transform: translateY(-50%);
  pointer-events: none; font-size: 10px; color: var(--muted);
}

button{
  border: none;
  border-radius: var(--radius-sm);
  padding: 10px 18px;
  font-family: inherit;
  font-weight: 600;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
}
button.primary{ background: var(--primary); color: white; box-shadow: 0 4px 6px -1px rgba(16, 185, 129, 0.3); }
button.primary:hover { background: var(--primary-dark); transform: translateY(-1px); }
button.primary:active { transform: translateY(0); }
button.secondary{ background: white; border: 1px solid var(--border); color: var(--text); }
button.secondary:hover { background: #f1f5f9; border-color: #cbd5e1; }
button:disabled{ opacity: 0.5; cursor: not-allowed; transform: none !important; box-shadow: none !important; }

/* ë©”ì¸ ì»¨í…ì¸  */
.contentArea {
  overflow-y: auto;
  position: relative;
  background: #f8fafc; 
}

/* ë°ìŠ¤í¬íƒ‘ì—ì„œë§Œ flex: 1 ì ìš© */
@media (min-width: 1024px) {
  .contentArea {
    flex: 1;
  }
}

.memo{
  margin: 16px;
  max-width: 600px;
  padding: 20px;
  background: white;
  border-radius: var(--radius);
  border: 1px solid var(--border);
  box-shadow: var(--shadow-sm);
  color: var(--text);
  line-height: 1.7;
  font-size: 15px;
}

@media (min-width: 1024px) {
  .memo { margin: 30px auto; padding: 30px; }
}
.memo p { margin: 0 0 12px 0; }
.memo strong { color: var(--primary-dark); }

.listWrap{ padding: 12px; max-width: 700px; margin: 0 auto; }

@media (min-width: 1024px) {
  .listWrap { padding: 20px; }
}
.list{ display:grid; gap: 10px; }

.item{
  display:flex;
  align-items:center;
  justify-content:space-between;
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 14px 18px;
  background: white;
  box-shadow: var(--shadow-sm);
  user-select:none;
  cursor: grab;
  touch-action: none;
  transition: transform 0.2s, box-shadow 0.2s;
}
.item:hover { transform: translateY(-2px); box-shadow: var(--shadow); border-color: var(--primary-light); }
.item:active{ cursor: grabbing; transform: scale(0.98); }

.label{ font-size: 17px; font-weight: 700; color: var(--text); }
.handle{ font-size: 12px; color: var(--muted); background: #f1f5f9; padding: 6px 10px; border-radius: 6px; font-weight: 600; }

.sortable-ghost{ opacity: 0.6; background: var(--accent); border: 2px dashed var(--primary); }
.sortable-chosen{ background: white; box-shadow: var(--shadow-lg); }

/* í•˜ë‹¨ ì €ì‘ê¶Œ í‘œì‹œ */
.footer {
  text-align: center;
  padding: 10px;
  font-size: 11px;
  color: var(--muted);
  background: white; /* or #f8fafc */
  border-top: 1px solid var(--border);
  border-radius: 0 0 var(--radius) var(--radius);
  font-weight: 500;
  opacity: 0.7;
}

/* ëª¨ë‹¬ ê³µí†µ */
.modalOverlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(15, 23, 42, 0.4); backdrop-filter: blur(8px);
  z-index: 99999;
  display: flex; align-items: center; justify-content: center; padding: 20px;
}
.modalCard {
  background: white; width: 100%; max-width: 400px; padding: 32px;
  border-radius: 24px; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
  text-align: center; animation: slideUp 0.4s cubic-bezier(0.16, 1, 0.3, 1);
  position: relative;
}
.modalCloseBtn {
  position: absolute; top: 16px; right: 16px;
  background: #f1f5f9; border: none; font-size: 18px; line-height: 1;
  width: 32px; height: 32px; border-radius: 50%; color: var(--muted); cursor: pointer;
  display: flex; align-items: center; justify-content: center; transition: 0.2s;
}
.modalCloseBtn:hover { background: #e2e8f0; color: var(--text); }

@keyframes slideUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

.loginTitle { font-size: 22px; font-weight: 800; margin-bottom: 8px; color: var(--text); }
.loginDesc { font-size: 14px; color: var(--muted); margin-bottom: 24px; }
.inputGroup { margin-bottom: 16px; text-align: left; }
.inputLabel { display: block; font-size: 13px; font-weight: 700; color: var(--muted); margin-bottom: 6px; }
.inputField {
  width: 100%; padding: 12px 14px; border: 1px solid var(--border);
  border-radius: 12px; font-size: 16px; font-family: inherit; transition: 0.2s;
}
.inputField:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px var(--accent); }
.loginBtn { width: 100%; justify-content: center; margin-top: 10px; padding: 14px; font-size: 16px; }
.hidden { display: none !important; }

/* ë­í‚¹ ëª¨ë‹¬ ì»¨í…ì¸  */
.rank-list-modal {
  display: flex; flex-direction: column; gap: 8px; margin-top: 16px; margin-bottom: 16px;
}
.rank-item {
  display: flex; align-items: center; justify-content: space-between;
  font-size: 14px; color: var(--text); padding: 10px 14px;
  background: white; border-radius: 12px; border: 1px solid var(--border);
}
.rank-item.top1 { border-color: #fbbf24; background: #fffbeb; }
.rank-rank { width: 24px; font-weight: 800; color: var(--muted); }
.rank-item.top1 .rank-rank { color: #d97706; }
.rank-name { flex: 1; font-weight: 600; text-align: left; margin-left: 8px; }
.rank-time { font-family: monospace; font-weight: 700; color: var(--primary-dark); }
.rank-empty { font-size: 13px; color: var(--muted); padding: 20px; }

/* í† ìŠ¤íŠ¸ */
.toast-msg {
  position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
  background: rgba(30, 41, 59, 0.9); color: white; padding: 10px 20px;
  border-radius: 30px; font-size: 14px; font-weight: 500; pointer-events: none;
  opacity: 0; transition: opacity 0.3s;
}
.toast-msg.show { opacity: 1; }

/* ì—…ì  ë‹¬ì„± íŒì—… */
.achievement-popup {
  position: fixed; top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.6); z-index: 20000;
  display: flex; align-items: center; justify-content: center;
  opacity: 0; pointer-events: none; transition: opacity 0.3s;
}
.achievement-popup.show { opacity: 1; pointer-events: auto; }
.achievement-card {
  background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
  border: 3px solid #f59e0b; border-radius: 24px;
  padding: 32px 48px; text-align: center;
  box-shadow: 0 20px 60px rgba(0,0,0,0.3), 0 0 40px rgba(245,158,11,0.4);
  animation: achievePop 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
  max-width: 90vw;
}
@keyframes achievePop {
  0% { transform: scale(0.5) rotate(-5deg); opacity: 0; }
  100% { transform: scale(1) rotate(0); opacity: 1; }
}
.achievement-icon { font-size: 64px; margin-bottom: 12px; }
.achievement-title { font-size: 14px; color: #92400e; font-weight: 600; margin-bottom: 4px; }
.achievement-name { font-size: 28px; font-weight: 900; color: #78350f; margin-bottom: 8px; }
.achievement-desc { font-size: 14px; color: #a16207; }

/* ì•„ë°”íƒ€ ì„ íƒ ì˜µì…˜ */
.avatar-option {
  font-size: 28px; cursor: pointer; padding: 6px;
  border-radius: 8px; transition: 0.2s;
}
.avatar-option:hover { background: #e0f2fe; transform: scale(1.2); }
.avatar-option.locked { 
  opacity: 0.3; filter: grayscale(100%); cursor: not-allowed;
}
.avatar-option.locked:hover { background: none; transform: none; }

/* ì™„ë£Œ ëª¨ë‹¬ ì „ìš© ìŠ¤íƒ€ì¼ */
.finish-title { font-size: 28px; font-weight: 900; color: var(--primary-dark); margin-bottom: 12px; }
.finish-message { font-size: 18px; font-weight: 700; color: var(--text); margin-bottom: 24px; line-height: 1.5; }
.finish-stats { 
  background: #f8fafc; border: 1px solid var(--border); border-radius: 16px; 
  padding: 16px; margin-bottom: 24px; display: grid; grid-template-columns: 1fr 1fr; gap: 12px;
}
.stat-item { display: flex; flex-direction: column; gap: 4px; }
.stat-label { font-size: 12px; color: var(--muted); font-weight: 600; }
.stat-value { font-size: 18px; font-weight: 800; color: var(--primary-dark); font-family: monospace; }
/* Utility */
.hidden { display: none !important; }
</style>

</head>

<body>

<!-- ë¡œê·¸ì¸ ëª¨ë‹¬ (hidden by default, shown if no session) -->
<div class="modalOverlay hidden" id="loginModal">
  <div class="modalCard">
    <div class="loginTitle">ì‹¤í—˜ ì°¸ê°€ì ì •ë³´</div>
    <div class="loginDesc">ë°ì´í„° ìˆ˜ì§‘ì„ ìœ„í•´ ì •ë³´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.</div>
    
    <!-- íƒ­ ë²„íŠ¼ -->
    <div style="display:flex; gap:10px; margin-bottom:20px; border-bottom:1px solid var(--border);">
      <button id="tabLogin" class="tab-btn active" style="flex:1; padding:10px; background:none; border:none; border-bottom:2px solid var(--primary); font-weight:700; color:var(--text);">ë¡œê·¸ì¸</button>
      <button id="tabRegister" class="tab-btn" style="flex:1; padding:10px; background:none; border:none; border-bottom:2px solid transparent; font-weight:600; color:var(--muted);">íšŒì›ê°€ì…</button>
    </div>

    <div class="inputGroup">
      <label class="inputLabel">ì•„ì´ë””</label>
      <input type="text" id="inputId" class="inputField" placeholder="ID ì…ë ¥" autofocus>
    </div>
    <div class="inputGroup">
      <label class="inputLabel">ë¹„ë°€ë²ˆí˜¸</label>
      <input type="password" id="inputPw" class="inputField" placeholder="ë¹„ë°€ë²ˆí˜¸ ì…ë ¥">
    </div>
    <div class="inputGroup" id="nameGroup" style="display:none;">
      <label class="inputLabel">ì´ë¦„ (ë‹‰ë„¤ì„)</label>
      <input type="text" id="inputName" class="inputField" placeholder="ë­í‚¹ì— í‘œì‹œë  ì´ë¦„">
    </div>
    
    <div id="loginMsg" style="color:#ef4444; font-size:13px; margin-bottom:10px; display:none;"></div>

    <button class="primary loginBtn" id="authActionBtn">ë¡œê·¸ì¸</button>
  </div>
</div>

<!-- ë­í‚¹ ëª¨ë‹¬ (NEW) -->
<div class="modalOverlay hidden" id="rankingModal">
  <div class="modalCard" style="max-width:450px;">
    <button class="modalCloseBtn" id="rankingCloseBtn">âœ•</button>
    <div class="loginTitle">ğŸ† ëª…ì˜ˆì˜ ì „ë‹¹</div>
    
    <!-- íƒ­ ë²„íŠ¼ -->
    <div style="display:flex; gap:8px; margin-bottom:16px;">
        <button id="rankTabSolo" class="rankTab active" onclick="switchRankTab('solo')" style="flex:1; padding:10px; border:none; border-radius:8px; background:#0ea5e9; color:white; font-weight:700; cursor:pointer;">ğŸ® ì†”ë¡œ</button>
        <button id="rankTabPvp" class="rankTab" onclick="switchRankTab('pvp')" style="flex:1; padding:10px; border:none; border-radius:8px; background:#e2e8f0; color:#64748b; font-weight:700; cursor:pointer;">âš”ï¸ PVP</button>
    </div>
    
    <div class="loginDesc" id="rankingModalSubtitle">Best Records</div>
    
    <div id="rankList" style="max-height:300px; overflow-y:auto; padding-right:8px;">
      <!-- JSë¡œ ì±„ì›Œì§ -->
    </div>
    
    <button class="secondary loginBtn" id="rankingOkBtn">ë‹«ê¸°</button>
  </div>
</div>

<!-- ë§ˆì´í˜ì´ì§€ ëª¨ë‹¬ (NEW) -->
<div class="modalOverlay hidden" id="myPageModal">
  <div class="modalCard" style="max-width: 600px; text-align:left;">
    <button class="modalCloseBtn" onclick="document.getElementById('myPageModal').classList.add('hidden')">âœ•</button>
    
    <div style="display:flex; align-items:center; gap:15px; margin-bottom:20px; border-bottom:1px solid #e2e8f0; padding-bottom:20px;">
        <div id="profileAvatar" onclick="showAvatarPicker()" style="width:60px; height:60px; background:#e0f2fe; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:30px; cursor:pointer; transition:0.2s; position:relative;" title="í´ë¦­í•˜ì—¬ ì•„ë°”íƒ€ ë³€ê²½">ğŸ§‘â€ğŸ’»
            <div style="position:absolute; bottom:-2px; right:-2px; background:#f1f5f9; font-size:10px; width:18px; height:18px; border-radius:4px; display:flex; align-items:center; justify-content:center;">âœï¸</div>
        </div>
        <div>
            <div style="display:flex; align-items:center; gap:8px;">
                <span style="font-size:20px; font-weight:800; color:#0f172a;" id="myNameDisplay">User</span>
                <button onclick="enableNameEdit()" style="font-size:12px; padding:2px 6px; background:#f1f5f9; border:none; border-radius:4px; cursor:pointer;" title="ì´ë¦„ ë³€ê²½">âœï¸</button>
            </div>
            <div id="nameEditForm" class="hidden" style="margin-top:5px; gap:5px;">
                <input type="text" id="newNameInput" style="padding:4px; border:1px solid #cbd5e1; border-radius:4px; font-size:14px; width:100px;">
                <button onclick="saveNewName()" style="padding:4px 8px; background:#3b82f6; color:white; border:none; border-radius:4px; font-size:12px; cursor:pointer;">ì €ì¥</button>
            </div>
            <div style="font-size:14px; color:#64748b;" id="myIdDisplay">ID: test</div>
        </div>
        <div style="margin-left:auto;">
            <button onclick="logout()" style="padding:8px 16px; background:#ef4444; color:white; border:none; border-radius:8px; font-size:12px; font-weight:600; cursor:pointer;">ë¡œê·¸ì•„ì›ƒ</button>
        </div>
    </div>
    
    <!-- ì•„ë°”íƒ€ ì„ íƒ ì˜ì—­ (ë™ì ìœ¼ë¡œ ì±„ì›Œì§) -->
    <div id="avatarPicker" style="display:none; margin-bottom:15px; padding:12px; background:#f8fafc; border-radius:12px; border:1px solid #e2e8f0; max-height:180px; overflow-y:auto;">
        <div style="font-size:12px; color:#64748b; margin-bottom:8px;">ğŸ­ ê¸°ë³¸ ì•„ë°”íƒ€</div>
        <div id="baseAvatars" style="display:flex; gap:8px; flex-wrap:wrap; margin-bottom:10px;"></div>
        <div style="font-size:12px; color:#64748b; margin-bottom:8px;">ğŸ† ì—…ì  ì•„ë°”íƒ€ <span style="font-size:10px;">(ì—…ì  ë‹¬ì„± ì‹œ í•´ê¸ˆ)</span></div>
        <div id="achievementAvatars" style="display:flex; gap:8px; flex-wrap:wrap;"></div>
    </div>

    <!-- PVP ì „ì  ì„¹ì…˜ -->
    <div style="margin-bottom:20px; padding:16px; background:#f0fdf4; border:1px solid #bbf7d0; border-radius:12px;">
        <div style="font-size:14px; font-weight:700; color:#166534; margin-bottom:12px;">âš”ï¸ PVP ì „ì </div>
        <div id="pvpStatsDisplay" style="display:flex; gap:16px; flex-wrap:wrap; justify-content:center;">
            <div style="text-align:center;">
                <div style="font-size:24px; font-weight:800; color:#0f172a;" id="pvpTotalGames">0</div>
                <div style="font-size:11px; color:#64748b;">ì „</div>
            </div>
            <div style="text-align:center;">
                <div style="font-size:24px; font-weight:800; color:#22c55e;" id="pvpWins">0</div>
                <div style="font-size:11px; color:#64748b;">ìŠ¹</div>
            </div>
            <div style="text-align:center;">
                <div style="font-size:24px; font-weight:800; color:#ef4444;" id="pvpLosses">0</div>
                <div style="font-size:11px; color:#64748b;">íŒ¨</div>
            </div>
            <div style="text-align:center;">
                <div style="font-size:24px; font-weight:800; color:#3b82f6;" id="pvpWinRate">0%</div>
                <div style="font-size:11px; color:#64748b;">ìŠ¹ë¥ </div>
            </div>
        </div>
    </div>

    <div style="font-size:16px; font-weight:800; margin-bottom:15px; ">ğŸ–ï¸ íšë“í•œ ì—…ì </div>
    <div id="myAchList" style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:10px; max-height:250px; overflow-y:auto;">
        <!-- JSì±„ì›€ -->
    </div>
  </div>
</div>

<!-- ì™„ë£Œ ì¶•í•˜ ëª¨ë‹¬ (NEW) -->
<div class="modalOverlay hidden" id="finishModal">
  <div class="modalCard" style="max-width: 450px;">
    <div class="finish-title">ğŸ‰ ì •ë ¬ ì™„ë£Œ!</div>
    <div class="finish-message" id="finishMessage">ì¶•í•˜í•©ë‹ˆë‹¤!</div>
    
    <div class="finish-stats">
      <div class="stat-item">
        <span class="stat-label">ì†Œìš” ì‹œê°„</span>
        <span class="stat-value" id="finishTimeVal">0.00s</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">ë‚œì´ë„</span>
        <span class="stat-value" id="finishDifficultyVal">-</span>
      </div>
    </div>
    
    <button class="primary loginBtn" id="finishCloseBtn" style="font-size: 18px; padding: 16px;">í™•ì¸</button>
  </div>
</div>

<!-- PVP Modals Moved to End of Body -->


<!-- Desktop HUD -->
<div class="hud-pill" id="desktopHud">
  <div class="hud-item">
    <span>â³ ì‹œê°„</span>
    <span class="hud-val timer-display">0.00</span>
  </div>
  <div class="hud-sep"></div>
  <div class="hud-item">
    <span>ğŸ“Š ì§„í–‰ë„</span>
    <span class="hud-val progress-text-display">0%</span>
  </div>
</div>

<div class="card" id="card">
  <!-- í—¤ë” -->
  <div class="header">

    <div class="headerTop">
      <div class="titleBox">
        <div class="title">ì •ë ¬ ìƒ‰ì¸ ì‹¤í—˜</div>
        <div class="sub">ë‹¨ì–´ë¥¼ ê°€ë‚˜ë‹¤ìˆœìœ¼ë¡œ ë¹ ë¥´ê²Œ ì •ë ¬í•˜ì„¸ìš”</div>
      </div>
      
      <!-- [1] ë©”ì¸ ë²„íŠ¼ ì˜ì—­ (ëŒ€ê¸° ì¤‘ í‘œì‹œ) -->
      <div class="ranking-btn-area active" id="rankingBtnArea">
        <button id="showRankingBtn" class="rank-open-btn" style="flex:1;">
           <span>ğŸ† ë­í‚¹ ë³´ê¸°</span>
        </button>
        <button id="myPageBtnMain" class="rank-open-btn" style="flex:1;">
           <span>â­ ì—…ì  ë³´ê¸°</span>
        </button>
      </div>

      <!-- [2] ê²Œì„ ì¤‘ ìƒíƒœ íŒ¨ë„ (íƒ€ì´ë¨¸/ì§„í–‰ë„) -->
      <div class="game-status-panel" id="gameStatusPanel">
        <div class="statusGroup">
          <div id="status" class="badge">ì§„í–‰ ì¤‘</div>
          <div id="timer" class="timerBadge timer-display">0.00</div>
        </div>
        <div class="progress-area">
          <div class="progress-label">
            <span>ì§„í–‰ë„</span>
            <span id="progressText" class="progress-text-display">0%</span>
          </div>
          <div class="gaugeWrap" aria-label="ì§„í–‰ë„">
            <div id="gaugeBar" class="gaugeBar"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- ì»¨íŠ¸ë¡¤ -->
  <div class="controls" id="controlsArea">
    <div class="select-wrapper">
      <select id="sizeSel">
        <option value="10" selected>í•˜ë‚¨ì (10ê°œ)</option>
        <option value="20">ì¤‘ë‚¨ì (20ê°œ)</option>
        <option value="40">ìƒë‚¨ì (40ê°œ)</option>
        <option value="80">ì”¹ìƒë‚¨ì (80ê°œ)</option>
      </select>
      <div class="select-caret">â–¼</div>
    </div>

    <div style="flex: 1;"></div> <!-- ê³µê°„ í™•ë³´ìš© -->

    <div class="hud-toggle-container">
      <span>ìƒë‹¨ HUD</span>
      <label class="switch">
        <input type="checkbox" id="hudToggle" checked>
        <span class="slider"></span>
      </label>
    </div>

    <button class="primary" id="startBtn"><span>â–¶</span> ì‹¤í—˜ ì‹œì‘</button>
  </div>

  <!-- ì»¨í…ì¸  ì˜ì—­ -->
  <div class="contentArea">
    <div class="memo" id="memoBox">
      <p><strong>ì•ˆë…•í•˜ì„¸ìš”, ì‹¤í—˜ì— ì°¸ì—¬í•´ ì£¼ì…”ì„œ ê°ì‚¬í•©ë‹ˆë‹¤.</strong></p>
      <p>ì´ ì›¹ì‚¬ì´íŠ¸ëŠ” ì‚¬ëŒì´ ë°ì´í„°ë¥¼ ì •ë ¬í•  ë•Œ ì†Œìš”ë˜ëŠ” ì‹œê°„ê³¼ íŒ¨í„´ì„ ë¶„ì„í•˜ê¸° ìœ„í•´ ì œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.</p>
      <p>
        1. <strong>[ì‹¤í—˜ ì‹œì‘]</strong> ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ ë‹¨ì–´ë“¤ì´ ë¬´ì‘ìœ„ë¡œ ë‚˜íƒ€ë‚©ë‹ˆë‹¤.<br>
        2. ë“œë˜ê·¸ ì•¤ ë“œë¡­ì„ ì´ìš©í•´ <strong>ê°€ë‚˜ë‹¤ìˆœ</strong>ìœ¼ë¡œ ì •ë ¬í•´ì£¼ì„¸ìš”.<br>
        3. <strong>í™”ë©´ ìœ„ì•„ë˜ ëìœ¼ë¡œ ë“œë˜ê·¸í•˜ë©´ ìë™ìœ¼ë¡œ ìŠ¤í¬ë¡¤ë©ë‹ˆë‹¤.</strong><br>
        4. ì •ë ¬ì´ ì™„ë£Œë˜ë©´ ìë™ìœ¼ë¡œ ì¢…ë£Œë˜ë©°, <strong>Top 5 ì•ˆì— ë“¤ë©´ ìƒí’ˆì„ ë°›ìœ¼ì‹¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤!</strong>
      </p>
      <p style="color:var(--muted); font-size:13px; margin-top:20px;">
        â€» ìˆ˜ì§‘ëœ ë°ì´í„°ëŠ” ì—°êµ¬ ëª©ì ìœ¼ë¡œë§Œ ì‚¬ìš©ë©ë‹ˆë‹¤.
      </p>
    </div>

    <div class="listWrap" id="listWrap" style="display:none;">
      <div id="list" class="list"></div>
    </div>
  </div>
  
  <div class="footer">
    Â© 32nd ì—„ì§€ì˜¤, 32nd ì´ë„í˜œ
  </div>
  
  <div class="toast-msg" id="toast"></div>
</div>

<!-- ì—…ì  ë‹¬ì„± íŒì—… -->
<div class="achievement-popup" id="achievementPopup">
  <div class="achievement-card">
    <div class="achievement-icon" id="achPopupIcon">ğŸ†</div>
    <div class="achievement-title">ğŸ‰ ì—…ì  ë‹¬ì„±!</div>
    <div class="achievement-name" id="achPopupName">ì—…ì  ì´ë¦„</div>
    <div class="achievement-desc" id="achPopupDesc">ì—…ì  ì„¤ëª…</div>
  </div>
</div>

<!-- ì´ˆê¸°í™” ë²„íŠ¼ (ì¹´ë“œ ì™¸ë¶€ í”Œë¡œíŒ…) -->
<button class="secondary floating-reset-btn" id="resetBtn" disabled style="display:none;"><span>â†º</span> ë©”ì¸ìœ¼ë¡œ</button>

<!-- ë¡œê·¸ ë‹¤ìš´ë¡œë“œ ë²„íŠ¼ ì œê±°ë¨ (ê´€ë¦¬ìëŠ” admin.phpì—ì„œ ë‹¤ìš´ë¡œë“œ ê°€ëŠ¥) -->

<!-- PVP Modals (Moved for layout stability) -->
<div class="modalOverlay hidden" id="modeSelectModal">
  <div class="modalCard" style="max-width: 400px; text-align:center;">
    <button class="modalCloseBtn" onclick="document.getElementById('modeSelectModal').classList.add('hidden')">âœ•</button>
    <div style="font-size:24px; font-weight:800; margin-bottom:20px; text-align:center;">ğŸ® ëª¨ë“œ ì„ íƒ</div>
    <div style="display:flex; flex-direction:column; gap:12px; align-items:center;">
      <button class="secondary" onclick="startSoloGame()" style="padding:16px 32px; font-size:16px; width:100%; text-align:center;">ğŸ‘¤ í˜¼ì í•˜ê¸°</button>
      <button class="primary loginBtn" onclick="openPvpLobby()" style="padding:16px 32px; font-size:16px; width:100%;">âš”ï¸ ëŒ€ì „ í•˜ê¸°</button>
    </div>
  </div>
</div>

<!-- PVP ë¡œë¹„ ëª¨ë‹¬ -->
<div class="modalOverlay hidden" id="pvpLobbyModal">
  <div class="modalCard" style="max-width: 500px; text-align:left;">
    <button class="modalCloseBtn" onclick="closePvpLobby()">âœ•</button>
    <div style="font-size:22px; font-weight:800; margin-bottom:16px;">âš”ï¸ ëŒ€ì „ ë¡œë¹„</div>
    <div style="display:flex; gap:4px; margin-bottom:16px; border-bottom:1px solid #e2e8f0;">
      <button id="pvpTab1" onclick="setPvpTab(1)" style="padding:10px 16px; border:none; background:none; font-weight:600; cursor:pointer; border-bottom:2px solid var(--primary); color:var(--primary);">ë°© ëª©ë¡</button>
      <button id="pvpTab2" onclick="setPvpTab(2)" style="padding:10px 16px; border:none; background:none; font-weight:600; cursor:pointer; border-bottom:2px solid transparent; color:#64748b;">ë°© ë§Œë“¤ê¸°</button>
    </div>
    <div id="pvpPanel1">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
        <span style="font-size:14px; color:#64748b;">ëŒ€ê¸° ì¤‘ì¸ ë°©</span>
        <div style="display:flex; gap:6px;">
          <button onclick="quickStart()" style="padding:4px 10px; font-size:12px; background:var(--primary); color:white; border:none; border-radius:4px; cursor:pointer;">âš¡ ë¹ ë¥¸ì‹œì‘</button>
          <button onclick="refreshRoomList()" style="padding:4px 10px; font-size:12px; background:#f1f5f9; border:none; border-radius:4px; cursor:pointer;">ğŸ”„ ìƒˆë¡œê³ ì¹¨</button>
        </div>
      </div>
      <div id="publicRoomList" style="max-height:200px; overflow-y:auto;"></div>
    </div>
    <div id="pvpPanel2" style="display:none;">
      <div style="margin-bottom:12px;">
        <label style="font-size:14px; color:#64748b;">ë°© ì œëª©</label>
        <input type="text" id="pvpRoomTitle" placeholder="ë°© ì œëª© ì…ë ¥" maxlength="20" style="width:100%; padding:12px; border:1px solid #cbd5e1; border-radius:8px; font-size:14px; margin-top:8px;">
      </div>
      <div style="margin-bottom:12px;">
        <label style="font-size:14px; color:#64748b;">ë‚œì´ë„</label>
        <select id="pvpCreateMode" style="width:100%; padding:12px; border:1px solid #cbd5e1; border-radius:8px; font-size:14px; margin-top:8px;">
          <option value="" disabled selected>ë‚œì´ë„ ì„ íƒ</option>
          <option value="10">í•˜ë‚¨ì (10ê°œ)</option>
          <option value="20">ì¤‘ë‚¨ì (20ê°œ)</option>
          <option value="40">ìƒë‚¨ì (40ê°œ)</option>
          <option value="80">ì”¹ìƒë‚¨ì (80ê°œ)</option>
        </select>
      </div>
      <div style="margin-bottom:12px;">
        <label style="font-size:14px; color:#64748b;">ìµœëŒ€ ì¸ì›</label>
        <select id="pvpMaxPlayers" style="width:100%; padding:12px; border:1px solid #cbd5e1; border-radius:8px; font-size:14px; margin-top:8px;">
          <option value="2" selected>2ëª…</option>
          <option value="3">3ëª…</option>
          <option value="4">4ëª…</option>
          <option value="5">5ëª…</option>
          <option value="6">6ëª…</option>
          <option value="7">7ëª…</option>
          <option value="8">8ëª…</option>
        </select>
      </div>
      <div style="margin-bottom:16px;">
        <label style="font-size:14px; color:#64748b;">ë¹„ë°€ë²ˆí˜¸ (ì„ íƒ)</label>
        <input type="text" id="pvpPassword" placeholder="ë¹„ë°€ë²ˆí˜¸ ì—†ìœ¼ë©´ ë¹„ì›Œë‘ì„¸ìš”" style="width:100%; padding:12px; border:1px solid #cbd5e1; border-radius:8px; font-size:14px; margin-top:8px;">
      </div>
      <button class="primary loginBtn" onclick="createPvpRoom()" style="width:100%; padding:14px;">ë°© ë§Œë“¤ê¸°</button>
    </div>
    <!-- Lobby Chat -->
    <div style="margin-top:16px; border-top:1px solid #e2e8f0; padding-top:12px;">
      <div style="font-size:14px; font-weight:600; margin-bottom:8px;">ğŸ’¬ ë¡œë¹„ ì±„íŒ…</div>
      <div id="lobbyChatLog" style="height:80px; overflow-y:auto; padding:8px; font-size:12px; background:#f8fafc; border:1px solid #e2e8f0; border-radius:6px; margin-bottom:8px;"></div>
      <div style="display:flex; gap:4px;">
        <input type="text" id="lobbyChatInput" placeholder="ì±„íŒ… ì…ë ¥..." style="flex:1; padding:8px; border:1px solid #cbd5e1; border-radius:6px; font-size:12px;" onkeypress="if(event.key==='Enter') sendLobbyChat()">
        <button onclick="sendLobbyChat()" style="padding:8px 14px; background:var(--primary); color:white; border:none; border-radius:6px; font-size:12px; cursor:pointer;">ì „ì†¡</button>
      </div>
    </div>
  </div>
</div>

<!-- PVP ëŒ€ê¸°ì‹¤ ëª¨ë‹¬ -->
<div class="modalOverlay hidden" id="pvpWaitingModal">
  <div class="modalCard" style="max-width: 420px;">
    <div style="font-size:22px; font-weight:800; margin-bottom:12px;">âš”ï¸ ëŒ€ì „ ëŒ€ê¸°ì‹¤</div>
    <div id="pvpPlayerList" style="margin-bottom:16px; text-align:left;"></div>
    <div id="pvpCountdown" style="font-size:48px; font-weight:800; color:var(--primary); display:none;">3</div>
    <div id="pvpWaitingText" style="font-size:14px; color:#64748b; margin-bottom:12px;">í”Œë ˆì´ì–´ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...</div>
    <!-- Chat -->
    <div style="border:1px solid #e2e8f0; border-radius:8px; margin-bottom:12px;">
      <div id="pvpChatLog" style="height:100px; overflow-y:auto; padding:8px; font-size:12px; background:#f8fafc;"></div>
      <div style="display:flex; gap:4px; padding:4px;">
        <input type="text" id="pvpChatInput" placeholder="ì±„íŒ… ì…ë ¥..." style="flex:1; padding:6px 8px; border:1px solid #cbd5e1; border-radius:4px; font-size:12px;" onkeypress="if(event.key==='Enter') sendChat()">
        <button onclick="sendChat()" style="padding:6px 12px; background:var(--primary); color:white; border:none; border-radius:4px; font-size:12px; cursor:pointer;">ì „ì†¡</button>
      </div>
    </div>
    <div style="display:flex; gap:10px; justify-content:center; flex-wrap:wrap;">
      <button id="pvpReadyBtn" class="secondary" onclick="toggleReady()" style="padding:12px 24px;">âœ‹ ì¤€ë¹„</button>
      <button id="pvpStartBtn" class="primary" onclick="requestPvpStart()" style="padding:12px 24px; display:none;">ê²Œì„ ì‹œì‘</button>
      <button class="secondary" onclick="leavePvpRoom()" style="padding:12px 20px;">ë‚˜ê°€ê¸°</button>
    </div>
  </div>
</div>

<script src="./Sortable.js"></script>
<script>
/* ì„¤ì • */
const CSV_FILE = "./kr_korean.csv";
const PRIMARY_WORD_COL_NAME = "ë‹¨ì–´";
const SAMPLE_POOL_SIZE = 1500;
const MODE_SCROLL_MULT = { 10: 1.0, 20: 1.0, 40: 1.0, 80: 1.0 }; 
const BASE_MANUAL_SCROLL_SPEED = 15.0; 
const koCollator = new Intl.Collator("ko-KR", { sensitivity: "base" });

/* DOM */
const listEl = document.getElementById("list");
const listWrap = document.getElementById("listWrap");
const memoBox = document.getElementById("memoBox");
const initialModal = document.getElementById("initialModal");
const cardEl = document.getElementById("card");
const loginModal = document.getElementById("loginModal");
const myPageModal = document.getElementById("myPageModal");
const rankingModal = document.getElementById("rankingModal");
const gaugeBarEl = document.getElementById("gaugeBar");
const progressText = document.getElementById("progressText");
const timerEl = document.getElementById("timer");
const statusEl = document.getElementById("status");


// (Legacy Header Button Removed)
const startBtn = document.getElementById("startBtn");
const resetBtn = document.getElementById("resetBtn");
const sizeSel = document.getElementById("sizeSel");
// logBtn removed - logs are for admin only
const toast = document.getElementById("toast");
const desktopHud = document.getElementById("desktopHud");
const contentArea = document.querySelector(".contentArea");

const hudToggle = document.getElementById("hudToggle");

// ë­í‚¹ ë° íŒ¨ë„ UI
const gameStatusPanel = document.getElementById("gameStatusPanel");
const rankingBtnArea = document.getElementById("rankingBtnArea");
const showRankingBtn = document.getElementById("showRankingBtn");

const rankingCloseBtn = document.getElementById("rankingCloseBtn");
const rankingOkBtn = document.getElementById("rankingOkBtn");
const rankList = document.getElementById("rankList");
const rankingModalSubtitle = document.getElementById("rankingModalSubtitle");
const finishModal = document.getElementById("finishModal");
const finishMessage = document.getElementById("finishMessage");
const finishTimeVal = document.getElementById("finishTimeVal");
const finishDifficultyVal = document.getElementById("finishDifficultyVal");
const finishCloseBtn = document.getElementById("finishCloseBtn");
const myPageBtnMain = document.getElementById("myPageBtnMain");

if(myPageBtnMain){
    myPageBtnMain.addEventListener('click', async () => {
        if(!userInfo.id){ 
            showToast("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤."); 
            loginModal.classList.remove('hidden');
            return; 
        }

        // Refresh Data
        try {
            const res = await fetch(`${API_BASE}/achievements.php`, {
                method: "POST",
                headers: { "Content-Type": "application/x-www-form-urlencoded" },
                body: new URLSearchParams({ id: userInfo.id, mode: 'VIEW_ONLY', time: 0, error_count: 0 })
            });
            const data = await res.json();
            if(data.success){
                userInfo.achievements = data.all_achievements;
                updateMyPageUI(userInfo.achievements || [], data.global_stats || {});
            }
        } catch(e){ console.error(e); }
        
        myPageModal.classList.remove('hidden');
    });
}


/* ìƒíƒœê°’ */
let userInfo = { id: "", name: "" };

// function to start periodic session check
let sessionCheckInterval = null;
function startSessionCheck(){
    if(sessionCheckInterval) clearInterval(sessionCheckInterval);
    const checkSession = ()=>{
        if(!userInfo.id || !userInfo.session_token) return;
        fetch(`${API_BASE}/auth.php`, {
            method: 'POST',
            headers: {'Content-Type':'application/x-www-form-urlencoded'},
            body: new URLSearchParams({action:'validate_session', id:userInfo.id, session_token:userInfo.session_token})
        }).then(r=>r.json()).then(data=>{
            if(!data.valid){
                localStorage.removeItem('questree_user');
                userInfo = {id:'', name:''};
                alert('ë‹¤ë¥¸ ê¸°ê¸°ì—ì„œ ë¡œê·¸ì¸ë˜ì–´ ë¡œê·¸ì•„ì›ƒë˜ì—ˆìŠµë‹ˆë‹¤.');
                location.reload();
            }
        }).catch(()=>{});
    };
    sessionCheckInterval = setInterval(checkSession, 3000);
    document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible') checkSession(); });
}



// Restore session from localStorage
(function(){
    const saved = localStorage.getItem('questree_user');
    if(saved){
        try {
            const parsed = JSON.parse(saved);
            if(parsed.id) {
                userInfo = parsed;
                // Basic restore successful -> Hide modal immediately (FORCE)
                const lm = document.getElementById('loginModal');
                if(lm) {
                    lm.classList.add('hidden');
                    lm.style.display = 'none'; // Double tap
                }
                
                // Validate session with server if token exists
                if(parsed.session_token){
                    fetch(`${API_BASE}/auth.php`, {
                        method: 'POST',
                        headers: {'Content-Type':'application/x-www-form-urlencoded'},
                        body: new URLSearchParams({action:'validate_session', id:userInfo.id, session_token:userInfo.session_token})
                    }).then(r=>r.json()).then(data=>{
                        if(!data.valid){
                            localStorage.removeItem('questree_user');
                            userInfo = {id:'', name:''};
                            alert('ë‹¤ë¥¸ ê¸°ê¸°ì—ì„œ ë¡œê·¸ì¸ë˜ì–´ ë¡œê·¸ì•„ì›ƒë˜ì—ˆìŠµë‹ˆë‹¤.');
                            const loginModal = document.getElementById('loginModal');
                            if(loginModal) loginModal.classList.remove('hidden');
                        } else {
                            // Start session check if valid
                            startSessionCheck();
                        }
                    }).catch(()=>{});
                }
                
                // Update avatar when DOM is ready
                setTimeout(()=>{
                    const avatarEl = document.getElementById('profileAvatar');
                    if(avatarEl && userInfo.avatar) avatarEl.childNodes[0].textContent = userInfo.avatar;
                }, 100);
                return; // Session exists, keep modal hidden
            }
        } catch(e){
            // If data is corrupted, clear it
            localStorage.removeItem('questree_user');
        }
    }
    // No valid session - show login modal
    setTimeout(()=>{
        // Safety check: if we have user info, DO NOT show modal
        if(userInfo && userInfo.id) return;
        
        const loginModal = document.getElementById('loginModal');
        if(loginModal) {
            loginModal.classList.remove('hidden');
            loginModal.style.display = ''; // Clear inline style
        }
    }, 50);
})();
let started = false;
let finished = false;
let startTime = 0;
let timerId = null;
let N = 10;
let isDataReady = false;
let koPool = [];
let items = [];
let wordMap = [];    
let initialInv = 1;
let actionLog = [];
let sortableInst = null;
let dragging = false;
let lastClientY = null;
let scrollLoopId = null;

// ë¡œê¹…ìš© ìƒíƒœ
let orderBeforeMove = "";
let prevInversionCount = -1;
let errorCount = 0; // ì—ëŸ¬ ì´ë™ íšŸìˆ˜ (inversion ì¦ê°€ ì‹œ)

/* ë¡œê·¸ì¸ */
/* ë¡œê·¸ì¸ */
/* ë¡œê·¸ì¸ & íšŒì›ê°€ì… ë¡œì§ */
const tabLogin = document.getElementById("tabLogin");
const tabRegister = document.getElementById("tabRegister");
const authActionBtn = document.getElementById("authActionBtn");
const loginMsg = document.getElementById("loginMsg");
const nameGroup = document.getElementById("nameGroup");
const inputId = document.getElementById("inputId");
const inputPw = document.getElementById("inputPw");
const inputName = document.getElementById("inputName");

let authMode = "login"; // login | register

function setAuthMode(m){
  authMode = m;
  if(m === "login"){
    tabLogin.style.borderBottomColor = "var(--primary)";
    tabLogin.style.color = "var(--text)";
    tabRegister.style.borderBottomColor = "transparent";
    tabRegister.style.color = "var(--muted)";
    authActionBtn.textContent = "ë¡œê·¸ì¸";
    authActionBtn.classList.add("primary");
    authActionBtn.classList.remove("secondary");
    nameGroup.style.display = "none";
  } else {
    tabRegister.style.borderBottomColor = "var(--primary)";
    tabRegister.style.color = "var(--text)";
    tabLogin.style.borderBottomColor = "transparent";
    tabLogin.style.color = "var(--muted)";
    authActionBtn.textContent = "íšŒì›ê°€ì…";
    authActionBtn.classList.remove("primary");
    authActionBtn.classList.add("secondary");
    // visual cleanup
    authActionBtn.style.background = "#fff";
    authActionBtn.style.color = "var(--primary)";
    authActionBtn.style.border = "1px solid var(--primary)";
    nameGroup.style.display = "block";
  }
  loginMsg.style.display="none";
}

tabLogin.addEventListener("click", () => setAuthMode("login"));
tabRegister.addEventListener("click", () => setAuthMode("register"));

async function handleAuth(){
  const id=inputId.value.trim();
  const pw=inputPw.value.trim();
  const nm=inputName.value.trim();
  
  if(!id || !pw){ loginMsg.textContent="ì•„ì´ë””ì™€ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”."; loginMsg.style.display="block"; return; }
  if(authMode==="register" && !nm){ loginMsg.textContent="ì´ë¦„(ë‹‰ë„¤ì„)ì„ ì…ë ¥í•´ì£¼ì„¸ìš”."; loginMsg.style.display="block"; return; }
  
  authActionBtn.disabled = true;
  loginMsg.style.display="none";

  try {
    const res = await fetch(`${API_BASE}/auth.php`, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: new URLSearchParams({ action: authMode, id: id, pw: pw, name: nm })
    });
    const data = await res.json();
    
    if(data.success){
      userInfo.id = id; 
      userInfo.name = data.name || nm;
      userInfo.avatar = data.avatar || '';
      userInfo.achievements = data.achievements || [];
      userInfo.pvp_stats = data.pvp_stats || {wins: 0, losses: 0};
      userInfo.session_token = data.session_token || '';
      loginModal.classList.add("hidden");
      showToast(authMode==="login" ? `í™˜ì˜í•©ë‹ˆë‹¤, ${userInfo.name}ë‹˜!` : "ê°€ì… ì™„ë£Œ! í™˜ì˜í•©ë‹ˆë‹¤.");
      // Save to localStorage for persistence
      localStorage.setItem('questree_user', JSON.stringify(userInfo));
      // Update avatar display if available
      if(userInfo.avatar){
        const avatarEl = document.getElementById('profileAvatar');
        if(avatarEl) avatarEl.childNodes[0].textContent = userInfo.avatar;
      }
      startSessionCheck(); // Start session check loop
    } else if(data.duplicate){
      // Duplicate login detected - ask to force login
      if(confirm(data.message)){
        // Retry with force flag
        const forceRes = await fetch(`${API_BASE}/auth.php`, {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: new URLSearchParams({ action: 'login', id: id, pw: pw, force: 'true' })
        });
        const forceData = await forceRes.json();
        if(forceData.success){
          userInfo.id = id; 
          userInfo.name = forceData.name;
          userInfo.avatar = forceData.avatar || '';
          userInfo.achievements = forceData.achievements || [];
          userInfo.session_token = forceData.session_token || '';
          loginModal.classList.add("hidden");
          showToast(`í™˜ì˜í•©ë‹ˆë‹¤, ${userInfo.name}ë‹˜!`);
          localStorage.setItem('questree_user', JSON.stringify(userInfo));
          startSessionCheck(); // Start session check loop
        } else {
          loginMsg.textContent = forceData.message || "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.";
          loginMsg.style.display="block";
        }
      }
    } else {
      loginMsg.textContent = data.message || "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.";
      loginMsg.style.display="block";
    }
  } catch(e) {
    console.error(e);
    loginMsg.textContent = "ì„œë²„ í†µì‹  ì˜¤ë¥˜";
    loginMsg.style.display="block";
  } finally {
    authActionBtn.disabled = false;
  }
}
authActionBtn.addEventListener("click", handleAuth);
inputId.addEventListener("keyup", (e)=>{ if(e.key==="Enter") inputPw.focus(); });
inputPw.addEventListener("keyup", (e)=>{ 
  if(e.key==="Enter") {
    if(authMode==="login") handleAuth();
    else inputName.focus();
  }
});
inputName.addEventListener("keyup", (e)=>{ if(e.key==="Enter") handleAuth(); });

/* ìœ í‹¸ */
function showToast(msg){
  toast.innerText = msg; toast.classList.add("show");
  setTimeout(()=> toast.classList.remove("show"), 2000);
}
function setStatus(state){
  statusEl.className = "badge"; statusEl.textContent = state;
  if(state === "ì§„í–‰ ì¤‘") statusEl.classList.add("run");
  else if(state === "ì™„ë£Œ") statusEl.classList.add("done");
}
function updateTimer(){
  if(!started || finished) return;
  const t = ((performance.now() - startTime) / 1000).toFixed(2);
  document.querySelectorAll(".timer-display").forEach(el => el.textContent = t);
}
function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]] = [arr[j],arr[i]];
  }
}
function escapeHtml(s){ return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;"); }
function isSortedKeys(keys){ for(let i=1;i<keys.length;i++) if(keys[i-1] > keys[i]) return false; return true; }
function currentKeys(){ return Array.from(listEl.querySelectorAll(".item")).map(el => Number(el.dataset.key)); }
function currentWids(){ return Array.from(listEl.querySelectorAll(".item")).map(el => Number(el.dataset.wid)); }
function inversionCount(keys){
  let inv=0; for(let i=0;i<keys.length;i++) for(let j=i+1;j<keys.length;j++) if(keys[i] > keys[j]) inv++; return inv;
}
function updateGauge(keys){
  const inv = inversionCount(keys);
  const ratio = (initialInv <= 0) ? (inv === 0 ? 1 : 0) : (1 - (inv / initialInv));
  const pct = Math.max(0, Math.min(1, ratio)) * 100;
  gaugeBarEl.style.width = pct.toFixed(1) + "%";
  const str = Math.floor(pct) + "%";
  document.querySelectorAll(".progress-text-display").forEach(el => el.textContent = str);
  return inv;
}

/* ë­í‚¹ ì‹œìŠ¤í…œ (LocalStorage Model) */
/* ë­í‚¹ ì‹œìŠ¤í…œ (Server Model - PHP) */
const API_BASE = "./api"; // PHP Backend Relative Path

async function getRanks(modeKey){
  try {
    const res = await fetch(`${API_BASE}/rankings.php?mode=${modeKey}`);
    if(!res.ok) return [];
    return await res.json();
  } catch(e) {
    console.error("Failed to fetch ranks:", e);
    return [];
  }
}

async function saveRanking(modeKey, name, timeVal){
  try {
    await fetch(`${API_BASE}/rankings.php`, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: new URLSearchParams({
        mode: modeKey,
        name: name,
        time: timeVal
      })
    });
  } catch(e) {
    console.error("Failed to save rank:", e);
    showToast("ë­í‚¹ ì €ì¥ ì‹¤íŒ¨ (ì„œë²„ ì—°ê²° í™•ì¸)");
  }
}
async function openRankingModal(modeKey){
  if(!modeKey) modeKey = sizeSel.options[sizeSel.selectedIndex].text; 
  const key = sizeSel.value;
  rankingModalSubtitle.textContent = `${modeKey} Ranking`;

  // Show loading state or empty first
  rankList.innerHTML = `<div class="rank-empty">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>`;
  rankingModal.classList.remove("hidden");

  const ranks = await getRanks(key);
  
  if(ranks.length === 0){
    rankList.innerHTML = `<div class="rank-empty">ì•„ì§ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.<br>ì²« ë²ˆì§¸ ì£¼ì¸ê³µì´ ë˜ì–´ë³´ì„¸ìš”!</div>`;
  } else {
    // Render Function
    const renderList = (limit) => {
      let html = "";
      ranks.slice(0, limit).forEach((r, idx) => {
        const cls = idx === 0 ? "rank-item top1" : "rank-item";
        html += `
          <div class="${cls}">
            <div style="display:flex; align-items:center;">
               <span class="rank-rank">${idx+1}</span>
               <span class="rank-name">${escapeHtml(r.name)}</span>
            </div>
            <span class="rank-time">${Number(r.time).toFixed(2)}s</span>
          </div>
        `;
      });
      return html;
    };

    // State
    let isExpanded = false;

    // Update View Function
    const updateView = () => {
        // CONTENT
        rankList.innerHTML = renderList(isExpanded ? 100 : 5); // 5 or 100

        // BUTTON (Only if > 5)
        // BUTTON (Only if > 5)
        if(ranks.length > 5){
            const btnDiv = document.createElement("div");
            // Use flexbox to force absolute centering
            btnDiv.style.cssText = "display:flex; justify-content:center; width:100%; margin-top:15px; padding-bottom:5px;";
            
            const btn = document.createElement("button");
            btn.textContent = isExpanded ? "â–² ì ‘ê¸° (Top 5)" : `â–¼ ì „ì²´ ìˆœìœ„ ë³´ê¸° (Total ${ranks.length})`;
            btn.style.cssText = `
                background:white; border:1px solid #ddd; padding:8px 24px; 
                border-radius:20px; color:#555; font-size:13px; font-weight:600; 
                cursor:pointer; box-shadow:0 2px 5px rgba(0,0,0,0.05); transition:all 0.2s;
            `;
            btn.onmouseover = () => { btn.style.borderColor='#aaa'; btn.style.color='#333'; };
            btn.onmouseout = () => { btn.style.borderColor='#ddd'; btn.style.color='#555'; };
            
            btn.onclick = () => {
                isExpanded = !isExpanded;
                updateView(); // Re-render
                
                // If expanding, scroll down a bit
                if(isExpanded) {
                    setTimeout(()=>{
                        const el = document.querySelectorAll('.rank-item')[5];
                        if(el) el.scrollIntoView({behavior:'smooth', block:'center'});
                    }, 50);
                } else {
                    // If collapsing, scroll back to top of list
                    rankList.scrollTop = 0;
                }
            };
            btnDiv.appendChild(btn);
            rankList.appendChild(btnDiv);
        }
    };

    // Initial Draw
    updateView();
  }
}

/* [UI] ë­í‚¹ ë²„íŠ¼ ë° ëª¨ë‹¬ í•¸ë“¤ëŸ¬ */
showRankingBtn.addEventListener("click", () => {
  rankingModal.classList.remove("hidden");
  switchRankTab('solo');
});
function closeRankingModal(){ rankingModal.classList.add("hidden"); }
rankingCloseBtn.addEventListener("click", closeRankingModal);
rankingOkBtn.addEventListener("click", closeRankingModal);
// ë°°ê²½ í´ë¦­ ì‹œ ë‹«ê¸°
rankingModal.addEventListener("click", (e)=>{ if(e.target===rankingModal) closeRankingModal(); });

/* [UI] ì™„ë£Œ ëª¨ë‹¬ í•¸ë“¤ëŸ¬ */
function openFinishModal(difficultyText, time, isTop5){
  finishDifficultyVal.textContent = difficultyText;
  finishTimeVal.textContent = time + "s";
  
  let msg = "ì •ë§ ëŒ€ë‹¨í•œ ì‹¤ë ¥ì´ì‹œë„¤ìš”!";
  if(difficultyText.includes("ì”¹ìƒë‚¨ì")) msg = "ì¶•í•˜í•©ë‹ˆë‹¤!<br>ë‹¹ì‹ ì€ ì§„ì •í•œ <span style='color:#ef4444'>ì”¹ìƒë‚¨ì</span>ì…ë‹ˆë‹¤! ğŸ’ª";
  else if(difficultyText.includes("ìƒë‚¨ì")) msg = "ì™€ìš°! ë‹¹ì‹ ì€ ë©‹ì§„ <span style='color:#3b82f6'>ìƒë‚¨ì</span>êµ°ìš”! ğŸ”¥";
  else if(difficultyText.includes("ì¤‘ë‚¨ì")) msg = "ì •ì„ì ì¸ ì‹¤ë ¥ì´ë„¤ìš”! <span style='color:#10b981'>ì¤‘ë‚¨ì</span> ì¸ì •í•©ë‹ˆë‹¤! ğŸ‘";
  else msg = "ìˆ˜ê³ í•˜ì…¨ìŠµë‹ˆë‹¤!<br>ë‹¤ìŒì—” ë” ë†’ì€ ë‚œì´ë„ì— ë„ì „í•´ë³´ì„¸ìš”! ğŸ˜Š";
  
  finishMessage.innerHTML = msg;

  if(isTop5) {
    let rewardHtml = "";
    if(difficultyText.includes("ì”¹ìƒë‚¨ì")) {
      rewardHtml = "ğŸ ë­í‚¹ Top 5 ë‹¬ì„± ë³´ìƒ!<br><span style='font-size:16px;'>1316 ì—„ì§€ì˜¤ì—ê²Œ ì˜¤ì‹œë©´<br><b>'ë‚˜ë‘ë“œì‚¬ì´ë‹¤ + ê³¼ì'</b>ë¥¼ ë“œë¦½ë‹ˆë‹¤!</span>";
    } else if(difficultyText.includes("ìƒë‚¨ì")) {
      rewardHtml = "ğŸ ë­í‚¹ Top 5 ë‹¬ì„± ë³´ìƒ!<br><span style='font-size:16px;'>1316 ì—„ì§€ì˜¤ì—ê²Œ ì˜¤ì‹œë©´<br><b>'ê³¼ì'</b>ë¥¼ ë“œë¦½ë‹ˆë‹¤!</span>";
    } else if(difficultyText.includes("ì¤‘ë‚¨ì")) {
      rewardHtml = "ğŸ ë­í‚¹ Top 5 ë‹¬ì„± ë³´ìƒ!<br><span style='font-size:16px;'>1316 ì—„ì§€ì˜¤ì—ê²Œ ì˜¤ì‹œë©´<br><b>'ë‚˜ë‘ë“œì‚¬ì´ë‹¤'</b>ë¥¼ ë“œë¦½ë‹ˆë‹¤!</span>";
    } else {
      rewardHtml = "ğŸ“¢ ë­í‚¹ Top 5 ë‹¬ì„±!<br><span style='font-size:15px;'>ì¶•í•˜ë“œë¦½ë‹ˆë‹¤! í•˜ì§€ë§Œ...<br><b>í•˜ë‚¨ìì—ê² ë³´ìƒë”°ìœˆ ì—†ìŠµë‹ˆë‹¤!</b> ğŸ˜</span>";
    }

    const rewardMsg = document.createElement("div");
    rewardMsg.style.cssText = "margin-top:20px; padding:12px; background:#fff7ed; border:1px dashed #fbbf24; border-radius:12px; font-size:14px; color:#9a3412; font-weight:700;";
    rewardMsg.innerHTML = rewardHtml;
    finishMessage.appendChild(rewardMsg);
  }

  finishModal.classList.remove("hidden");
}
function closeFinishModal(){ finishModal.classList.add("hidden"); }
finishCloseBtn.addEventListener("click", closeFinishModal);
finishModal.addEventListener("click", (e)=>{ if(e.target===finishModal) closeFinishModal(); });



/* ë°ì´í„° ë¡œë“œ */
const cDiv = document.querySelector(".controls");
const lb = document.createElement("div");
lb.style.cssText = "font-size:12px;font-weight:600;color:#64748b;margin-left:auto;";
lb.textContent = "ë°ì´í„° ì¤€ë¹„ ì¤‘...";
if(cDiv) cDiv.insertBefore(lb, cDiv.firstChild);

async function initBackgroundDataLoad(){
  try{
    startBtn.disabled=true;
    const res = await fetch(CSV_FILE);
    if(!res.ok) throw new Error("File not found");
    const text = await res.text();
    await new Promise(r=>setTimeout(r,50));
    const reservoir = processCsvText(text);
    if(reservoir.length<100) throw new Error("Data missing");
    koPool=reservoir; 
    koPool.sort(); // Sort for PVP synchronization (deterministic order)
    isDataReady=true;
    lb.textContent="âœ” ì¤€ë¹„ ì™„ë£Œ"; lb.style.color="#10B981";
    if(!started) startBtn.disabled=false;
  }catch(e){
    console.error(e); lb.textContent="âŒ ë¡œë“œ ì‹¤íŒ¨"; lb.style.color="#ef4444";
  }
}
function splitCsvLine(line){ const out=[]; let cur=""; let inQ=false; for(let i=0;i<line.length;i++){const ch=line[i];if(ch==='"'){if(inQ&&line[i+1]==='"'){cur+='"';i++;}else inQ=!inQ;}else if(ch===','&&!inQ){out.push(cur);cur="";}else{cur+=ch;}}out.push(cur);return out;}
function processCsvText(txt){
  txt=txt.replace(/^\uFEFF/,""); const l=txt.split(/\r?\n/);
  if(l.length===0) return[];
  const h=splitCsvLine(l[0]).map(x=>x.trim());
  let idx=h.findIndex(x=>x===PRIMARY_WORD_COL_NAME); if(idx<0) idx=0;
  const s=new Set(); const r=[]; let c=0;
  for(let i=1;i<l.length;i++){
    if(l[i].trim().length===0)continue;
    const cols=splitCsvLine(l[i]); const w=String(cols[idx]||"").trim();
    if(!w||w.length<2||w.includes("-")||w.includes("^")||/[0-9]/.test(w)||s.has(w))continue;

    // ë§Œì•½ ìœ ë‹ˆì½”ë“œ íŠ¹ìˆ˜ ë¬¸ì(PUA ë“±)ê°€ í¬í•¨ë˜ì–´ ìˆìœ¼ë©´ ì œì™¸
    let hasPua = false;
    for(let j=0; j<w.length; j++) {
      const code = w.charCodeAt(j);
      if(code >= 0xE000 && code <= 0xF8FF) { hasPua = true; break; }
    }
    if(hasPua) continue;

    s.add(w); c++;
    if(r.length<SAMPLE_POOL_SIZE) r.push(w);
    else { const j=Math.floor(Math.random()*c); if(j<SAMPLE_POOL_SIZE) r[j]=w; }
  }
  shuffle(r); return r;
}
initBackgroundDataLoad();

/* ìŠ¤í¬ë¡¤ ë¡œì§ */
function getScrollMul(){ return MODE_SCROLL_MULT[Number(sizeSel.value)] ?? 1.5; }
function autoScrollByPointer(y){
  if(!dragging) return;
  const sc = contentArea; if(!sc) return;
  const r = sc.getBoundingClientRect();
  const m = 120; const bs = BASE_MANUAL_SCROLL_SPEED*getScrollMul();
  const top=r.top+m; const bot=r.bottom-m;
  let spd=0;
  if(y<top){ const i=Math.max(0,(top-y)/m); spd=-(bs+(i*i*50)); }
  else if(y>bot){ const i=Math.max(0,(y-bot)/m); spd=(bs+(i*i*50)); }
  if(spd!==0) sc.scrollTop+=spd;
}
function startScrollLoop(){ if(scrollLoopId) clearInterval(scrollLoopId); scrollLoopId=setInterval(()=>{ if(dragging&&lastClientY!==null) autoScrollByPointer(lastClientY); }, 12); }
function stopScrollLoop(){ if(scrollLoopId) clearInterval(scrollLoopId); scrollLoopId=null; }
document.addEventListener("touchmove",e=>{if(dragging&&e.touches[0])lastClientY=e.touches[0].clientY;},{passive:true});
document.addEventListener("mousemove",e=>{if(dragging)lastClientY=e.clientY;},{passive:true});

/* HUD Control */
function updateHud(forceOn, forceOff){
  if(forceOff) {
    desktopHud.classList.remove("visible");
    return;
  }
  
  const isEnabled = hudToggle.checked;
  if(started && isEnabled && !finished) {
    desktopHud.classList.add("visible");
  } else {
    desktopHud.classList.remove("visible");
  }
}
hudToggle.addEventListener("change", () => updateHud());

/* ê²Œì„ ë©”ì¸ */
function renderList(){
  listEl.innerHTML="";
  items.forEach(it=>{
    const d=document.createElement("div");
    d.className="item"; d.dataset.key=it.key; d.dataset.wid=it.wid;
    d.innerHTML=`<div class="label">${escapeHtml(it.label)}</div><div class="handle">â‰¡</div>`;
    listEl.appendChild(d);
  });
}
function ensureNotAlreadySorted(arr){
  const check = (list) => { for(let i=1;i<list.length;i++) if(list[i-1].key > list[i].key) return false; return true; };
  let temp=arr; for(let k=0; k<10; k++){ if(!check(temp)) return temp; shuffle(temp); } return temp;
}
function sampleUnique(pool, k){ const copy=[...pool]; shuffle(copy); return copy.slice(0, k); }

async function startRun(){
  if(!userInfo.id){ loginModal.classList.remove("hidden"); return; }
  if(!isDataReady){ showToast("ë°ì´í„° ë¡œë”© ì¤‘ì…ë‹ˆë‹¤."); return; }
  N = Number(sizeSel.value);
  setStatus("ì¤€ë¹„ ì¤‘");
  try{
    const pool = koPool;
    const picked = sampleUnique(pool, N);
    const sorted = [...picked].sort((a,b) => koCollator.compare(a,b));
    const rankMap = new Map(sorted.map((w,i)=>[w, i+1]));
    wordMap = picked.map(w => w); 
    let out = picked.map((w, i) => ({ wid: i+1, key: rankMap.get(w), label: w }));
    shuffle(out); items = ensureNotAlreadySorted(out);
  }catch(e){ setStatus("ì˜¤ë¥˜"); showToast("ìƒì„± ì‹¤íŒ¨"); return; }

  memoBox.style.display="none"; listWrap.style.display="block";
  resetBtn.disabled=false; resetBtn.style.display="block"; // í”Œë¡œíŒ… ë¦¬ì…‹ ë²„íŠ¼ í‘œì‹œ
  sizeSel.disabled=true; startBtn.disabled=true;

  started=true; finished=false; startTime=performance.now();
  document.querySelectorAll(".timer-display").forEach(el=>el.textContent="0.00");
  clearInterval(timerId); timerId=setInterval(updateTimer,50);

  renderList();
  const keys=currentKeys(); 
  initialInv=Math.max(1,inversionCount(keys)); 
  prevInversionCount=initialInv; 
  updateGauge(keys);
  
  setStatus("ì§„í–‰ ì¤‘"); 
  actionLog=[]; 
  errorCount=0; // ì—ëŸ¬ ì¹´ìš´íŠ¸ ì´ˆê¸°í™”
  logAction("INIT", 0, 0, 0, prevInversionCount, currentWids().join("|"));
  
  // UI ìƒíƒœ ì „í™˜: ë­í‚¹ ë²„íŠ¼ ìˆ¨ê¹€ -> ê²Œì„ íŒ¨ë„ í‘œì‹œ
  rankingBtnArea.classList.remove("active");
  gameStatusPanel.classList.add("active");
  
  // ê²Œì„ ì‹œì‘ ì‹œ ì¹´ë“œ í¬ê¸° ì¶•ì†Œ (80%)
  if(cardEl) cardEl.classList.add("game-active");

  initSortable();
  updateHud(true);

  setTimeout(() => {
     if(contentArea) contentArea.scrollTop = 0;
     window.scrollTo(0,0);
  }, 50);
}

function initSortable(){
  if(sortableInst) sortableInst.destroy();
  sortableInst = new Sortable(listEl, {
    forceFallback: true, animation: 200, ghostClass: "sortable-ghost", chosenClass: "sortable-chosen",
    scroll: contentArea, scrollSensitivity: 150, scrollSpeed: 20, bubbleScroll: true,
    onStart: (evt) => {
      dragging=true; orderBeforeMove=currentWids().join("|");
      try{ const r = evt.item.getBoundingClientRect(); lastClientY = (r.top + r.bottom) / 2; }catch(_){}
      startScrollLoop(); document.body.style.cursor="grabbing";
    },
    onEnd: (evt) => {
      dragging=false; stopScrollLoop(); document.body.style.cursor="";
      if(evt.oldIndex!==evt.newIndex){
        const keys = currentKeys();
        const currInv = inversionCount(keys);
        logAction("MOVE", evt.item.dataset.wid, evt.oldIndex, evt.newIndex, currInv, orderBeforeMove);
        checkFinish(keys, currInv);
        prevInversionCount = currInv;
      }
    }
  });
}

function logAction(act, wid, from, to, currInv, extraInfo){
  const dist = (act === "MOVE") ? Math.abs(from - to) : 0;
  const isError = (act === "MOVE" && currInv > prevInversionCount) ? 1 : 0;
  if(isError) errorCount++; // ì—ëŸ¬ ì´ë™ ì¹´ìš´íŠ¸
  const scrollPos = (contentArea) ? Math.floor(contentArea.scrollTop) + (window.scrollY || 0) : 0;
  
  actionLog.push({
    time: ((performance.now() - startTime)/1000).toFixed(3),
    mode: sizeSel.options[sizeSel.selectedIndex].text,
    action: act, 
    wid: wid || 0, 
    from_idx: from, 
    to_idx: to, 
    drag_dist: dist,
    scroll_pos: scrollPos,
    inversion: currInv,
    is_error: isError,
    order_snapshot: (act==="INIT") ? extraInfo : (act==="END" ? extraInfo : "") 
  });
}

function checkFinish(keys, currInv){
  if(!keys) keys = currentKeys();
  if(currInv === undefined) currInv = inversionCount(keys);
  
  updateGauge(keys);
  
  if(isSortedKeys(keys)){
    finished=true; clearInterval(timerId); setStatus("ì™„ë£Œ");
    sortableInst.option("disabled", true);
    gaugeBarEl.style.width="100%"; 
    document.querySelectorAll(".progress-text-display").forEach(el=>el.textContent="100%");
    
    // ë­í‚¹ ì €ì¥ (PVPë©´ ì €ì¥ ì•ˆí•¨)
    const finalTime = ((performance.now() - startTime) / 1000).toFixed(2);
    const difficultyText = sizeSel.options[sizeSel.selectedIndex].text;
    
    // PVP ëª¨ë“œ ì²´í¬ (ë³€ìˆ˜ê°€ ì„ ì–¸ë˜ì–´ ìˆì–´ì•¼ í•¨)
    const isPvp = (typeof pvpMode !== 'undefined' && pvpMode);

    if(!isPvp) {
      saveRanking(sizeSel.value, userInfo.name, finalTime).then(() => {
          checkTop5Reward(sizeSel.value, difficultyText, finalTime);
          checkAchievements(sizeSel.value, finalTime, errorCount);
      });
    }

    // Auto-Upload Logs
    logAction("END",0,0,0,0, currentWids().join("|"));
    uploadLogsToServer(); // Send logs immediately
    
    showToast(`ì •ë ¬ ì™„ë£Œ! ê¸°ë¡: ${finalTime}ì´ˆ`);

    // PVP ì™„ë£Œ ì²˜ë¦¬
    if(isPvp && typeof sendPvpFinish === 'function'){
      sendPvpFinish(finalTime);
    }
  }
}

async function checkTop5Reward(modeValue, difficultyText, finalTime){
  // Wait a bit to ensure server updated (simple approach) or just trust the response
  const ranks = await getRanks(modeValue);
  
  // Find where my record is
  // Strict check: Name match matches AND time is extremely close
  const myRankIdx = ranks.findIndex(r => r.name === userInfo.name && Math.abs(r.time - Number(finalTime)) < 0.01);
  
  // Only true if I am in index 0, 1, 2, 3, or 4 (Top 5)
  const isTop5 = (myRankIdx !== -1 && myRankIdx < 5);
  
  openFinishModal(difficultyText, finalTime, isTop5);
}

async function uploadLogsToServer(){
  const { c1, c2 } = generateLogContent();
  // Add timestamp to prevent overwriting
  const now = new Date();
  const timeStr = String(now.getHours()).padStart(2, '0') + String(now.getMinutes()).padStart(2, '0') + String(now.getSeconds()).padStart(2, '0');
  const isPvp = (typeof pvpMode !== 'undefined' && pvpMode);
  const p = `sorted_exp_${userInfo.id}_${userInfo.name}_${timeStr}${isPvp ? '_PVP' : ''}`;
  
  // Upload Actions Log
  fetch(`${API_BASE}/logs.php`, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: new URLSearchParams({ filename: `${p}_Actions_Enhanced.csv`, content: c1 })
  }).catch(e=>console.error("Log upload failed:",e));
  
  // Upload Words Log
  fetch(`${API_BASE}/logs.php`, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: new URLSearchParams({ filename: `${p}_Words.csv`, content: c2 })
  }).catch(e=>console.error("Log upload failed:",e));
}

async function checkAchievements(mode, time, errCount){
    if(!userInfo.id) return;
    try {
        const res = await fetch(`${API_BASE}/achievements.php`, {
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            body: new URLSearchParams({ 
                id: userInfo.id, 
                mode: mode, 
                time: time, 
                error_count: errCount
            })
        });
        const data = await res.json();
        if(data.success && data.new_achievements && data.new_achievements.length > 0){
            // ì—…ì  íŒì—… íì— ì¶”ê°€
            showAchievementQueue(data.new_achievements);
            userInfo.achievements = data.all_achievements;
        }
    } catch(e){ console.error("Achievement check failed", e); }
}

// ì—…ì  íŒì—… í‘œì‹œ í•¨ìˆ˜
let achievementQueue = [];
let isShowingAchievement = false;

function showAchievementQueue(achievements){
    achievementQueue.push(...achievements);
    if(!isShowingAchievement) showNextAchievement();
}

function showNextAchievement(){
    if(achievementQueue.length === 0){
        isShowingAchievement = false;
        return;
    }
    isShowingAchievement = true;
    const ach = achievementQueue.shift();
    
    document.getElementById('achPopupIcon').textContent = ach.icon || 'ğŸ†';
    document.getElementById('achPopupName').textContent = ach.name;
    document.getElementById('achPopupDesc').textContent = ach.desc;
    
    const popup = document.getElementById('achievementPopup');
    popup.classList.add('show');
    
    // í´ë¦­í•˜ë©´ ë‹«ê¸°
    popup.onclick = () => {
        popup.classList.remove('show');
        setTimeout(showNextAchievement, 300);
    };
    
    // 3ì´ˆ í›„ ìë™ ë‹«ê¸°
    setTimeout(() => {
        if(popup.classList.contains('show')){
            popup.classList.remove('show');
            setTimeout(showNextAchievement, 300);
        }
    }, 3000);
}

function generateLogContent(){
  const h = ["time","mode","action","moved_wid","from_idx","to_idx","drag_dist","scroll_pos","inversion_count","is_error_move","order_snapshot"];
  let c1 = h.join(",") + "\n";
  actionLog.forEach(r => { 
    c1 += [r.time, r.mode, r.action, r.wid, r.from_idx, r.to_idx, r.drag_dist, r.scroll_pos, r.inversion, r.is_error, r.order_snapshot].map(toCsvCell).join(",") + "\n"; 
  });
  let c2 = "wid,word\n";
  wordMap.forEach((w, i) => { c2 += `${i+1},${toCsvCell(w)}\n`; });
  c2 += `\nParticipant_ID,${toCsvCell(userInfo.id)}\nName,${toCsvCell(userInfo.name)}\nDate,${new Date().toLocaleString()}\n`;
  return { c1, c2 };
}

function resetAll(){
  started=false; finished=false; stopScrollLoop(); clearInterval(timerId);
  window.isResultRecorded = false; // Reset duplicate prevention flag
  if(typeof pvpResultPollInterval !== 'undefined' && pvpResultPollInterval) clearInterval(pvpResultPollInterval);
  if(sortableInst) sortableInst.destroy(); sortableInst=null;
  document.querySelectorAll(".timer-display").forEach(el=>el.textContent="0.00");
  setStatus("ëŒ€ê¸°"); gaugeBarEl.style.width="0%"; 
  document.querySelectorAll(".progress-text-display").forEach(el=>el.textContent="0%");
  listEl.innerHTML=""; items=[];
  sizeSel.disabled=false; startBtn.disabled=!isDataReady; resetBtn.disabled=true;
  resetBtn.style.display="none"; // í”Œë¡œíŒ… ë¦¬ì…‹ ë²„íŠ¼ ìˆ¨ê¹€
  memoBox.style.display="block"; listWrap.style.display="none";
  updateHud(false, true);
  
  // Restore finish close button
  const finishCloseBtn = document.getElementById('finishCloseBtn');
  if(finishCloseBtn) finishCloseBtn.style.display = 'block';
  
  // UI ìƒíƒœ ë³µêµ¬: ê²Œì„ íŒ¨ë„ ìˆ¨ê¹€ -> ë­í‚¹ ë²„íŠ¼ í‘œì‹œ
  gameStatusPanel.classList.remove("active");
  rankingBtnArea.classList.add("active");
  
  // ëŒ€ê¸° í™”ë©´ìœ¼ë¡œ ë³µê·€ ì‹œ ì¹´ë“œ í¬ê¸° í™•ëŒ€ (120%)
  if(cardEl) cardEl.classList.remove("game-active");
}
startBtn.addEventListener("click", openModeSelect);
resetBtn.addEventListener("click", resetAll);

function toCsvCell(v){ const s = String(v ?? ""); if(/[",\n]/.test(s)) return `"${s.replaceAll('"','""')}"`; return s; }
function downloadFile(fn, c){
  const BOM = "\uFEFF"; const blob = new Blob([BOM + c], { type: "text/csv;charset=utf-8;" });
  const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href = url; a.download = fn; document.body.appendChild(a); a.click(); a.remove();
}

// My Page UI Updater
function updateMyPageUI(myCodes, stats){
    const listDiv = document.getElementById('myAchList');
    if(!listDiv) return;
    
    // Definition mapping for display
    const achDefs = [
        { id: 'clear_easy', icon: 'ğŸš©', name: 'í•˜ë‚¨ì ì •ë³µ', desc: 'í•˜ë‚¨ì ë‚œì´ë„ í´ë¦¬ì–´' },
        { id: 'speed_easy', icon: 'ğŸ‘§', name: 'í•˜ë‚¨ìì˜ ì™•', desc: '10ì´ˆ ì´ë‚´ í´ë¦¬ì–´' },
        { id: 'clear_normal', icon: 'ğŸš©', name: 'ì¤‘ë‚¨ì ì •ë³µ', desc: 'ì¤‘ë‚¨ì ë‚œì´ë„ í´ë¦¬ì–´' },
        { id: 'speed_normal', icon: 'ğŸ‘¦', name: 'ì¤‘ë‚¨ìì˜ ì™•', desc: '60ì´ˆ ì´ë‚´ í´ë¦¬ì–´' },
        { id: 'clear_hard', icon: 'ğŸš©', name: 'ìƒë‚¨ì ì •ë³µ', desc: 'ìƒë‚¨ì ë‚œì´ë„ í´ë¦¬ì–´' },
        { id: 'speed_hard', icon: 'ğŸ˜', name: 'ìƒë‚¨ìì˜ ì™•', desc: '180ì´ˆ ì´ë‚´ í´ë¦¬ì–´' },
        { id: 'clear_extreme', icon: 'ğŸ¤«', name: 'ì”¹ìƒë‚¨ì ì •ë³µ', desc: 'ì”¹ìƒë‚¨ì ë‚œì´ë„ í´ë¦¬ì–´' },
        { id: 'speed_extreme', icon: 'ğŸ‘‘', name: 'ì”¹ìƒë‚¨ìì˜ ì™•', desc: '600ì´ˆ ì´ë‚´ í´ë¦¬ì–´' },
        { id: 'god_hand', icon: 'ğŸ¯', 'name': 'ì‹ ì˜ ì†', 'desc': 'ì§„í–‰ë„ë¥¼ ë‚®ì¶”ì§€ ì•Šê³  ì™„ë²½ í´ë¦¬ì–´' },
        { id: 'slow_steady', icon: 'ğŸ”¥', 'name': 'ë¶ˆêµ´ì˜ ì˜ì§€', 'desc': 'ì˜¤ëœ ì‹œê°„(ë‚œì´ë„ë³„ ê¸°ì¤€) ëì— ìŠ¹ë¦¬' },
        { id: 'ranker', icon: 'ğŸ†', 'name': 'ëª…ì˜ˆì˜ ì „ë‹¹', 'desc': 'ë­í‚¹ Top 5 ì§„ì…' },
        { id: 'goat', icon: 'ğŸ', 'name': 'GOAT', 'desc': 'ë­í‚¹ 1ìœ„ ë‹¬ì„±' },
        { id: 'lucky_seven', icon: 'ğŸ€', 'name': 'ëŸ­í‚¤ì„¸ë¸', 'desc': 'ê¸°ë¡ .77ì´ˆ ë‹¬ì„±' },
        { id: 'veteran_10', icon: 'âš”ï¸', 'name': 'ì „ì¥ì˜ ì§€ë°°ì', 'desc': '10íšŒ í´ë¦¬ì–´ ë‹¬ì„±' },
        { id: 'real_man', icon: 'â˜ ï¸', 'name': 'ë‚¨ìì¤‘ì˜ ë‚¨ì', 'desc': 'ì—…ì  10ê°œ ë‹¬ì„±' },
        { id: 'pvp_first_win', icon: 'ğŸ¥Š', 'name': 'ì²« ìŠ¹ë¦¬', 'desc': 'PVP ì²« ìŠ¹ë¦¬' },
        { id: 'pvp_10_wins', icon: 'ğŸ–ï¸', 'name': 'PVP ë§ˆìŠ¤í„°', 'desc': 'PVP 10ìŠ¹ ë‹¬ì„±' },
        { id: 'pvp_50_wins', icon: 'ğŸ’€', 'name': 'PVP ì „ì„¤', 'desc': 'PVP 50ìŠ¹ ë‹¬ì„±' },
        { id: 'pvp_5_streak', icon: 'ğŸ”¥', 'name': 'ë¶ˆíŒ¨', 'desc': 'PVP 5ì—°ìŠ¹' },
        { id: 'secret_master', icon: 'â“', 'name': '???', 'desc': '???', unlockedIcon: 'ğŸ”±', unlockedName: 'ì‹ ', unlockedDesc: 'ëª¨ë“  ì—…ì  ë‹¬ì„±' },
    ];

    let html = "";
    achDefs.forEach(def => {
        const has = myCodes.includes(def.id);
        // Show unlocked normally, locked as grayed out
        const style = has ? "opacity:1; background:#f0f9ff; border-color:#bae6fd;" : "opacity:0.5; filter:grayscale(100%); background:#f8fafc;";
        const per = (stats && stats[def.id] !== undefined) ? stats[def.id] + '%' : '0%';
        
        // Use unlocked name/desc/icon if available and unlocked
        const displayName = (has && def.unlockedName) ? def.unlockedName : def.name;
        const displayDesc = (has && def.unlockedDesc) ? def.unlockedDesc : def.desc;
        const displayIcon = (has && def.unlockedIcon) ? def.unlockedIcon : def.icon;
        
        html += `
            <div style="display:flex; align-items:center; gap:12px; padding:12px; border:1px solid #e2e8f0; border-radius:12px; ${style}">
                <div style="font-size:32px; flex-shrink:0;">${displayIcon}</div>
                <div style="flex:1; min-width:0;">
                    <div style="display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:4px;">
                        <span style="font-weight:700; color:#0f172a; font-size:15px; white-space:nowrap;">${displayName}</span>
                        <span style="font-size:11px; font-weight:600; color:#64748b; background:#e2e8f0; padding:2px 6px; border-radius:4px; white-space:nowrap;">ì „ì²´ ${per}</span>
                    </div>
                    <div style="font-size:12px; color:#64748b; margin-top:2px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${displayDesc}</div>
                </div>
            </div>
        `;
    });
    listDiv.innerHTML = html;
    
    // Update Profile Info (text only, don't replace structure)
    const nameDisp = document.getElementById('myNameDisplay');
    const idDisp = document.getElementById('myIdDisplay');
    const avatarEl = document.getElementById('profileAvatar');
    
    if(nameDisp) nameDisp.textContent = userInfo.name || "User";
    if(idDisp) idDisp.textContent = `ID: ${userInfo.id || "-"}`;
    if(avatarEl && userInfo.avatar) {
        avatarEl.childNodes[0].textContent = userInfo.avatar;
    }
    
    // Update PVP Stats
    const pvpStats = userInfo.pvp_stats || {wins: 0, losses: 0};
    const wins = pvpStats.wins || 0;
    const losses = pvpStats.losses || 0;
    const total = wins + losses;
    const winRate = total > 0 ? Math.round((wins / total) * 100) : 0;
    
    const totalEl = document.getElementById('pvpTotalGames');
    const winsEl = document.getElementById('pvpWins');
    const lossesEl = document.getElementById('pvpLosses');
    const rateEl = document.getElementById('pvpWinRate');
    
    if(totalEl) totalEl.textContent = total;
    if(winsEl) winsEl.textContent = wins;
    if(lossesEl) lossesEl.textContent = losses;
    if(rateEl) rateEl.textContent = winRate + '%';
}

// Global scope functions for Name Edit (toggle)
window.enableNameEdit = function(){
    const form = document.getElementById('nameEditForm');
    if(form.style.display === 'flex'){
        form.style.display = 'none';
    } else {
        form.classList.remove('hidden');
        form.style.display = 'flex';
        document.getElementById('newNameInput').value = userInfo.name || '';
    }
}
window.saveNewName = async function(){
    const newName = document.getElementById('newNameInput').value.trim();
    if(!newName) return;
    
    if(confirm(`ë‹‰ë„¤ì„ì„ '${newName}'(ìœ¼)ë¡œ ë³€ê²½í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n(ë­í‚¹íŒì˜ ê¸°ì¡´ ê¸°ë¡ë„ ëª¨ë‘ ë³€ê²½ë©ë‹ˆë‹¤.)`)){
        try {
            const res = await fetch(`${API_BASE}/update_profile.php`, {
                method: "POST",
                headers: { "Content-Type": "application/x-www-form-urlencoded" },
                body: new URLSearchParams({ id: userInfo.id, new_name: newName })
            });
            const data = await res.json();
            if(data.success){
                alert("ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.");
                userInfo.name = newName;
                document.getElementById('myNameDisplay').textContent = newName;
                document.getElementById('nameEditForm').style.display = 'none';
            } else {
                alert(data.message || "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
            }
        } catch(e){ console.error(e); alert("í†µì‹  ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."); }
    }
}

// ì•„ë°”íƒ€ ì„ íƒ ê¸°ëŠ¥
window.showAvatarPicker = function(){
    const picker = document.getElementById('avatarPicker');
    if(picker.style.display === 'none'){
        populateAvatarPicker(); // ì—´ ë•Œë§ˆë‹¤ ì—…ì  ìƒíƒœ ë°˜ì˜
        picker.style.display = 'block';
    } else {
        picker.style.display = 'none';
    }
}

window.selectAvatar = async function(emoji){
    // Update UI immediately
    const avatarEl = document.getElementById('profileAvatar');
    // Keep the edit badge, just change the main emoji
    avatarEl.childNodes[0].textContent = emoji;
    document.getElementById('avatarPicker').style.display = 'none';
    
    // Save to server
    try {
        await fetch(`${API_BASE}/update_profile.php`, {
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            body: new URLSearchParams({ id: userInfo.id, avatar: emoji })
        });
        userInfo.avatar = emoji;
        showToast("ì•„ë°”íƒ€ê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤!");
    } catch(e){ console.error(e); }
}

// ë¡œê·¸ì•„ì›ƒ ê¸°ëŠ¥
window.logout = function(){
    if(confirm("ë¡œê·¸ì•„ì›ƒ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")){
        if(typeof pvpRoomCode !== 'undefined' && pvpRoomCode && userInfo.id) {
            try { 
                const data = new URLSearchParams({action:'leave', room_code:pvpRoomCode, player_id:userInfo.id});
                navigator.sendBeacon(`${API_BASE}/pvp.php`, data);
            } catch(e){}
        }
        
        userInfo = { id: "", name: "", avatar: "" };
        localStorage.removeItem('questree_user');
        showToast("ë¡œê·¸ì•„ì›ƒ ë˜ì—ˆìŠµë‹ˆë‹¤.");
        
        // Reload to clear clean state
        setTimeout(() => location.reload(), 500);
    }
}

// ì•„ë°”íƒ€ í”¼ì»¤ ì±„ìš°ê¸° (ì—…ì  ê¸°ë°˜)
const BASE_AVATARS = ['ğŸ§‘â€ğŸ’»', 'ğŸ‘¤', 'ğŸ§‘', 'ğŸ‘©', 'ğŸ‘¨', 'ğŸ§’', 'ğŸ±', 'ğŸ¶', 'ğŸ»', 'ğŸ¦Š', 'ğŸ°', 'ğŸ¼'];
const ACHIEVEMENT_AVATARS = [
    { emoji: 'ğŸš©', achId: 'clear_easy', name: 'í•˜ë‚¨ì ì •ë³µ' },
    { emoji: 'ğŸ‘§', achId: 'speed_easy', name: 'í•˜ë‚¨ìì˜ ì™•' },
    { emoji: 'ğŸ‘¦', achId: 'speed_normal', name: 'ì¤‘ë‚¨ìì˜ ì™•' },
    { emoji: 'ğŸ˜', achId: 'speed_hard', name: 'ìƒë‚¨ìì˜ ì™•' },
    { emoji: 'ğŸ¤«', achId: 'clear_extreme', name: 'ì”¹ìƒë‚¨ì ì •ë³µ' },
    { emoji: 'ğŸ‘‘', achId: 'speed_extreme', name: 'ì”¹ìƒë‚¨ìì˜ ì™•' },
    { emoji: 'ğŸ¯', achId: 'god_hand', name: 'ì‹ ì˜ ì†' },
    { emoji: 'ğŸ”¥', achId: 'slow_steady', name: 'ë¶ˆêµ´ì˜ ì˜ì§€' },
    { emoji: 'ğŸ†', achId: 'ranker', name: 'ëª…ì˜ˆì˜ ì „ë‹¹' },
    { emoji: 'ğŸ', achId: 'goat', name: 'GOAT' },
    { emoji: 'ğŸ€', achId: 'lucky_seven', name: 'ëŸ­í‚¤ì„¸ë¸' },
    { emoji: 'âš”ï¸', achId: 'veteran_10', name: 'ì „ì¥ì˜ ì§€ë°°ì' },
    { emoji: 'â˜ ï¸', achId: 'real_man', name: 'ë‚¨ìì¤‘ì˜ ë‚¨ì' },
    { emoji: 'ğŸ”±', achId: 'secret_master', name: 'ì‹ ', lockedEmoji: 'â“', lockedName: '???' },
];

function populateAvatarPicker(){
    const myAchs = userInfo.achievements || [];
    
    // Base avatars
    const baseDiv = document.getElementById('baseAvatars');
    baseDiv.innerHTML = BASE_AVATARS.map(e => 
        `<span class="avatar-option" onclick="selectAvatar('${e}')">${e}</span>`
    ).join('');
    
    // Achievement avatars
    const achDiv = document.getElementById('achievementAvatars');
    achDiv.innerHTML = ACHIEVEMENT_AVATARS.map(a => {
        const unlocked = myAchs.includes(a.achId);
        // For secret achievement: show â“ when locked, actual emoji when unlocked
        const displayEmoji = unlocked ? a.emoji : (a.lockedEmoji || a.emoji);
        if(unlocked){
            return `<span class="avatar-option" onclick="selectAvatar('${a.emoji}')" title="${a.name}">${displayEmoji}</span>`;
        } else {
            return `<span class="avatar-option locked" title="ğŸ”’ ${a.lockedName || a.name} ì—…ì  ë‹¬ì„± í•„ìš”">${displayEmoji}</span>`;
        }
    }).join('');
}

// ============== PVP ì‹œìŠ¤í…œ ==============
let pvpMode = false;
let pvpRoomCode = null;
let pvpIsHost = false;
let pvpPollInterval = null;
let pvpSeed = null;
let pvpWords = null; // Server-provided word list for sync

function openModeSelect(){
    document.getElementById('modeSelectModal').classList.remove('hidden');
}
window.startSoloGame = function(){
    document.getElementById('modeSelectModal').classList.add('hidden');
    pvpMode = false;
    startRun();
}
window.openPvpLobby = function(){
    document.getElementById('modeSelectModal').classList.add('hidden');
    document.getElementById('pvpLobbyModal').classList.remove('hidden');
    setPvpTab(1);
    refreshRoomList();
    // Auto refresh every 1 second (no flicker since we only update on change)
    if(window.roomRefreshInterval) clearInterval(window.roomRefreshInterval);
    window.roomRefreshInterval = setInterval(refreshRoomList, 1000);
    // Start lobby chat polling
    refreshLobbyChat();
    if(window.lobbyChatInterval) clearInterval(window.lobbyChatInterval);
    window.lobbyChatInterval = setInterval(refreshLobbyChat, 1000);
}
window.closePvpLobby = function(){
    document.getElementById('pvpLobbyModal').classList.add('hidden');
    if(window.roomRefreshInterval) clearInterval(window.roomRefreshInterval);
    if(window.lobbyChatInterval) clearInterval(window.lobbyChatInterval);
}

async function refreshLobbyChat(){
    try {
        const res = await fetch(`${API_BASE}/pvp.php`, {
            method: 'POST',
            headers: {'Content-Type':'application/x-www-form-urlencoded'},
            body: new URLSearchParams({action:'lobby_chat_list'})
        });
        const data = await res.json();
        if(data.success && data.chat){
            const log = document.getElementById('lobbyChatLog');
            if(log){
                log.innerHTML = data.chat.map(c => `<div><b>${c.name}:</b> ${c.msg}</div>`).join('');
                log.scrollTop = log.scrollHeight;
            }
        }
    } catch(e){}
}

window.sendLobbyChat = async function(){
    const input = document.getElementById('lobbyChatInput');
    const msg = input.value.trim();
    if(!msg || !userInfo.id) return;
    input.value = '';
    // Show immediately locally
    const log = document.getElementById('lobbyChatLog');
    if(log){
        log.innerHTML += `<div><b>${userInfo.name}:</b> ${msg}</div>`;
        log.scrollTop = log.scrollHeight;
    }
    try {
        await fetch(`${API_BASE}/pvp.php`, {
            method: 'POST',
            headers: {'Content-Type':'application/x-www-form-urlencoded'},
            body: new URLSearchParams({action:'lobby_chat', name:userInfo.name, message:msg})
        });
    } catch(e){}
}

window.setPvpTab = function(n){
    for(let i=1; i<=2; i++){
        document.getElementById('pvpTab'+i).style.borderBottomColor = i===n ? 'var(--primary)' : 'transparent';
        document.getElementById('pvpTab'+i).style.color = i===n ? 'var(--primary)' : '#64748b';
        document.getElementById('pvpPanel'+i).style.display = i===n ? 'block' : 'none';
    }
}

const modeLabels = {'10':'í•˜ë‚¨ì','20':'ì¤‘ë‚¨ì','40':'ìƒë‚¨ì','80':'ì”¹ìƒë‚¨ì'};

window.refreshRoomList = async function(){
    const listEl = document.getElementById('publicRoomList');
    try {
        const res = await fetch(`${API_BASE}/pvp.php`, {
            method: 'POST',
            headers: {'Content-Type':'application/x-www-form-urlencoded'},
            body: new URLSearchParams({action:'list'})
        });
        const data = await res.json();
        let newHtml;
        if(data.success && data.rooms.length > 0){
            newHtml = data.rooms.map(r => `
                <div style="display:flex; justify-content:space-between; align-items:center; padding:12px; border:1px solid #e2e8f0; border-radius:8px; margin-bottom:8px;">
                    <div>
                        <div style="font-weight:600;">${r.has_password ? 'ğŸ”’ ' : ''}${r.title}</div>
                        <div style="font-size:12px; color:#64748b;">${modeLabels[r.mode] || r.mode} | ${r.current_players}/${r.max_players}ëª…</div>
                    </div>
                    <button onclick="joinRoom('${r.code}', ${r.has_password})" style="padding:8px 16px; background:var(--primary); color:white; border:none; border-radius:6px; cursor:pointer;">ì…ì¥</button>
                </div>
            `).join('');
        } else {
            newHtml = '<div style="text-align:center; color:#64748b; padding:20px;">ëŒ€ê¸° ì¤‘ì¸ ë°©ì´ ì—†ìŠµë‹ˆë‹¤</div>';
        }
        // Only update if content changed to prevent flicker
        if(listEl.innerHTML !== newHtml) listEl.innerHTML = newHtml;
    } catch(e){ if(!listEl.innerHTML) listEl.innerHTML = '<div style="color:red; padding:20px;">ì˜¤ë¥˜</div>'; }
}

window.createPvpRoom = async function(){
    const title = document.getElementById('pvpRoomTitle').value.trim();
    const mode = document.getElementById('pvpCreateMode').value;
    if(!mode){ alert('ë‚œì´ë„ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”'); return; }
    const maxPlayers = document.getElementById('pvpMaxPlayers').value;
    const password = document.getElementById('pvpPassword').value.trim();
    
    // Prevent double click
    const btn = event.target;
    if(btn.disabled) return;
    btn.disabled = true;
    btn.textContent = 'ìƒì„± ì¤‘...';
    
    try {
        const res = await fetch(`${API_BASE}/pvp.php`, {
            method: 'POST',
            headers: {'Content-Type':'application/x-www-form-urlencoded'},
            body: new URLSearchParams({action:'create', host_id:userInfo.id, host_name:userInfo.name, title:title, mode:mode, max_players:maxPlayers, password:password})
        });
        const text = await res.text();
        console.log('Create response:', text);
        let data;
        try { data = JSON.parse(text); } catch(pe) { alert('ì„œë²„ ì‘ë‹µ ì˜¤ë¥˜: ' + text); return; }
        if(data.success){
            pvpRoomCode = data.room_code;
            pvpIsHost = true;
            pvpMode = true;
            curMode = parseInt(mode);
            document.getElementById('pvpLobbyModal').classList.add('hidden');
            showWaitingRoom();
        } else { alert(data.message || 'ë°© ìƒì„± ì‹¤íŒ¨'); }
    } catch(e){ alert('ë°© ìƒì„± ì‹¤íŒ¨: ' + e.message); console.error(e); }
    
    btn.disabled = false;
    btn.textContent = 'ë°© ë§Œë“¤ê¸°';
}

// Quick start - join random public room
window.quickStart = async function(){
    try {
        const res = await fetch(`${API_BASE}/pvp.php`, {
            method: 'POST',
            headers: {'Content-Type':'application/x-www-form-urlencoded'},
            body: new URLSearchParams({action:'list'})
        });
        const data = await res.json();
        if(data.success && data.rooms.length > 0){
            // Filter public rooms (no password) that are not full
            const publicRooms = data.rooms.filter(r => !r.has_password && r.current_players < r.max_players);
            if(publicRooms.length > 0){
                const room = publicRooms[Math.floor(Math.random() * publicRooms.length)];
                joinRoom(room.code, false);
            } else {
                alert('ì…ì¥ ê°€ëŠ¥í•œ ê³µê°œë°©ì´ ì—†ìŠµë‹ˆë‹¤');
            }
        } else {
            alert('ëŒ€ê¸° ì¤‘ì¸ ë°©ì´ ì—†ìŠµë‹ˆë‹¤');
        }
    } catch(e){ alert('ë¹ ë¥¸ì‹œì‘ ì‹¤íŒ¨'); }
}

window.joinPrivateRoom = function(){
    const code = document.getElementById('pvpJoinCode').value.trim().toUpperCase();
    if(!code) return alert('ë°© ì½”ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”');
    joinRoom(code);
}

window.joinRoom = async function(code, hasPassword=false){
    let password = '';
    if(hasPassword){
        password = prompt('ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”:');
        if(password === null) return;
    }
    try {
        const res = await fetch(`${API_BASE}/pvp.php`, {
            method: 'POST',
            headers: {'Content-Type':'application/x-www-form-urlencoded'},
            body: new URLSearchParams({action:'join', room_code:code, player_id:userInfo.id, player_name:userInfo.name, password:password})
        });
        const data = await res.json();
        if(data.success){
            pvpRoomCode = code;
            pvpIsHost = false;
            pvpMode = true;
            curMode = parseInt(data.mode);
            document.getElementById('pvpLobbyModal').classList.add('hidden');
            showWaitingRoom();
        } else { alert(data.message); }
    } catch(e){ alert('ì…ì¥ ì‹¤íŒ¨'); }
}

function showWaitingRoom(){
    document.getElementById('pvpWaitingModal').classList.remove('hidden');
    document.getElementById('pvpPlayerList').innerHTML = '';
    document.getElementById('pvpCountdown').style.display = 'none';
    document.getElementById('pvpWaitingText').textContent = 'í”Œë ˆì´ì–´ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...';
    document.getElementById('pvpStartBtn').style.display = pvpIsHost ? 'block' : 'none';
    
    // Ready button: host is auto-ready, hide for host
    const readyBtn = document.getElementById('pvpReadyBtn');
    if(pvpIsHost){
        readyBtn.style.display = 'none';
        myReady = true;
    } else {
        readyBtn.style.display = 'block';
        readyBtn.textContent = 'âœ‹ ì¤€ë¹„';
        readyBtn.classList.remove('primary');
        readyBtn.classList.add('secondary');
        myReady = false;
    }
    
    startPvpPolling();
}

function startPvpPolling(){
    if(pvpPollInterval) clearInterval(pvpPollInterval);
    const poll = async()=>{
        try {
            const res = await fetch(`${API_BASE}/pvp.php`, {
                method: 'POST',
                headers: {'Content-Type':'application/x-www-form-urlencoded'},
                body: new URLSearchParams({action:'status', room_code:pvpRoomCode, player_id:userInfo.id})
            });
            const data = await res.json();
            if(!data.success) return;
            
            // Update Host Status
            if(data.room && data.room.host_id === userInfo.id) {
                if(!pvpIsHost) {
                    pvpIsHost = true;
                    // Ensure start button visibility for new host
                    const startBtn = document.getElementById('pvpStartBtn');
                    if(startBtn) startBtn.style.display = 'block';
                }
            }
            
            // Update player list
            const listHtml = data.players.map((p, i) => 
                `<div style="padding:8px; background:${p.ready ? '#ecfdf5' : '#f8fafc'}; border-radius:6px; margin-bottom:6px; display:flex; justify-content:space-between; border:1px solid ${p.ready ? '#10b981' : '#e2e8f0'};">
                    <span>${i===0 ? 'ğŸ‘‘ ' : ''}${p.name}</span>
                    <span style="font-size:12px;">${i===0 ? '' : (p.ready ? 'âœ… ì¤€ë¹„ì™„ë£Œ' : 'â³ ëŒ€ê¸°ì¤‘')}</span>
                </div>`
            ).join('');
            document.getElementById('pvpPlayerList').innerHTML = listHtml;
            
            // Sync myReady status for guest
            if(!pvpIsHost){
                const me = data.players.find(p => p.id === userInfo.id);
                if(me){
                    if(me.ready !== myReady){
                        myReady = me.ready;
                        const btn = document.getElementById('pvpReadyBtn');
                        if(btn){
                            if(myReady){
                                 btn.textContent = 'âœ… ì¤€ë¹„ì™„ë£Œ';
                                 btn.classList.remove('secondary');
                                 btn.classList.add('primary');
                            } else {
                                 btn.textContent = 'âœ‹ ì¤€ë¹„';
                                 btn.classList.remove('primary');
                                 btn.classList.add('secondary');
                            }
                        }
                    }
                }
            }
            
            const allReady = data.players.every(p => p.ready);
            document.getElementById('pvpWaitingText').textContent = allReady && data.players.length >= 2 
                ? 'ëª¨ë‘ ì¤€ë¹„ ì™„ë£Œ!' 
                : `${data.players.length}/${data.max_players}ëª… ì°¸ê°€ ì¤‘`;
            
            // Check if host & can start (all players ready)
            if(pvpIsHost && data.players.length >= 2 && data.status === 'waiting'){
                document.getElementById('pvpStartBtn').style.display = 'block';
                document.getElementById('pvpStartBtn').disabled = !allReady;
            }
            
            // Update chat log
            if(data.chat){
                const chatLog = document.getElementById('pvpChatLog');
                if(chatLog){
                    chatLog.innerHTML = data.chat.map(c => 
                        `<div><b>${c.name}:</b> ${c.msg}</div>`
                    ).join('');
                    chatLog.scrollTop = chatLog.scrollHeight;
                }
            }
            
            // Game started by host
            if(data.status === 'playing' && data.seed){
                pvpSeed = data.seed;
                pvpWords = data.words ? JSON.parse(data.words) : null; // Store words from server
                startPvpCountdown(data.start_time);
                clearInterval(pvpPollInterval);
            }
            
            // if we are waiting for host to reset, ignore finished status
            if(data.status === 'waiting'){
                window.ignoreFinishStatus = false;
            }
            
            // Game finished - show results
            if(data.status === 'finished' && !window.ignoreFinishStatus){
                clearInterval(pvpPollInterval);
                showMultiplayerResult(data.players);
            }
        } catch(e){}
    };
    poll();
    pvpPollInterval = setInterval(poll, 1500);
}

function startPvpCountdown(startTime){
    document.getElementById('pvpWaitingText').textContent = 'ê³§ ì‹œì‘í•©ë‹ˆë‹¤!';
    document.getElementById('pvpCountdown').style.display = 'block';
    const tick = ()=>{
        const now = Math.floor(Date.now()/1000);
        const remaining = startTime - now;
        if(remaining <= 0){
            document.getElementById('pvpWaitingModal').classList.add('hidden');
            actualStartPvpGame();
        } else {
            document.getElementById('pvpCountdown').textContent = remaining;
            setTimeout(tick, 500);
        }
    };
    tick();
}

function seededRandom(seed){
    return function(){
        seed = (seed * 9301 + 49297) % 233280;
        return seed / 233280;
    };
}

// Host requests game start (button click) - generates and sends word list
window.requestPvpStart = async function(){
    if(!pvpIsHost) return;
    try {
        // Host generates word list
        N = curMode;
        const pool = [...koPool];
        shuffle(pool);
        const picked = pool.slice(0, N);
        const wordsJson = JSON.stringify(picked);
        
        const res = await fetch(`${API_BASE}/pvp.php`, {
            method: 'POST',
            headers: {'Content-Type':'application/x-www-form-urlencoded'},
            body: new URLSearchParams({action:'start', room_code:pvpRoomCode, host_id:userInfo.id, words:wordsJson})
        });
        const data = await res.json();
        if(!data.success) alert(data.message);
    } catch(e){ alert('ì‹œì‘ ì‹¤íŒ¨'); }
}

window.sendChat = async function(){
    const input = document.getElementById('pvpChatInput');
    const msg = input.value.trim();
    if(!msg || !pvpRoomCode) return;
    input.value = '';
    try {
        await fetch(`${API_BASE}/pvp.php`, {
            method: 'POST',
            headers: {'Content-Type':'application/x-www-form-urlencoded'},
            body: new URLSearchParams({action:'chat', room_code:pvpRoomCode, name:userInfo.name, message:msg})
        });
    } catch(e){}
}

let myReady = false;
window.toggleReady = async function(){
    try {
        const res = await fetch(`${API_BASE}/pvp.php`, {
            method: 'POST',
            headers: {'Content-Type':'application/x-www-form-urlencoded'},
            body: new URLSearchParams({action:'ready', room_code:pvpRoomCode, player_id:userInfo.id})
        });
        const data = await res.json();
        if(data.success){
            myReady = !myReady;
            const btn = document.getElementById('pvpReadyBtn');
            if(myReady){
                btn.textContent = 'âœ… ì¤€ë¹„ì™„ë£Œ';
                btn.classList.remove('secondary');
                btn.classList.add('primary');
            } else {
                btn.textContent = 'âœ‹ ì¤€ë¹„';
                btn.classList.remove('primary');
                btn.classList.add('secondary');
            }
        }
    } catch(e){}
}

function actualStartPvpGame(){
    // Use words from server (host-generated)
    if(!pvpWords || pvpWords.length === 0){
        alert('ë‹¨ì–´ ëª©ë¡ì„ ë°›ì§€ ëª»í–ˆìŠµë‹ˆë‹¤');
        return;
    }
    
    N = pvpWords.length;
    const picked = pvpWords;
    console.log('[PVP] Using server words:', picked);
    
    // Sort for ranking
    const sorted = [...picked].sort((a,b) => koCollator.compare(a,b));
    const rankMap = new Map(sorted.map((w,i)=>[w, i+1]));
    wordMap = picked.map(w => w);
    let out = picked.map((w, i) => ({ wid: i+1, key: rankMap.get(w), label: w }));
    
    // Shuffle display order using seed
    const rng = seededRandom(pvpSeed);
    for(let i=out.length-1; i>0; i--){
        const j = Math.floor(rng() * (i+1));
        [out[i], out[j]] = [out[j], out[i]];
    }
    items = out;
    
    memoBox.style.display="none"; listWrap.style.display="block";
    // PVP ëª¨ë“œì—ì„œëŠ” ë¦¬ì…‹ ë²„íŠ¼ ìˆ¨ê¹€ (ê¸°ê¶Œ ë°©ì§€)
    resetBtn.disabled=false; resetBtn.style.display= pvpMode ? "none" : "block";
    sizeSel.disabled=true; startBtn.disabled=true;
    
    started=true; finished=false; startTime=performance.now();
    document.querySelectorAll(".timer-display").forEach(el=>el.textContent="0.00");
    clearInterval(timerId); timerId=setInterval(updateTimer,50);
    
    renderList();
    const keys=currentKeys();
    initialInv=Math.max(1,inversionCount(keys));
    prevInversionCount=initialInv;
    updateGauge(keys);
    
    setStatus("ì§„í–‰ ì¤‘");
    actionLog=[];
    errorCount=0;
    
    rankingBtnArea.classList.remove("active");
    gameStatusPanel.classList.add("active");
    if(cardEl) cardEl.classList.add("game-active");
    
    initSortable();
    if(!pvpMode) updateHud(true); // PVPì—ì„œëŠ” í”Œë¡œíŒ… HUD ìˆ¨ê¹€
    
    // PVP ëª¨ë“œ: ì§„í–‰ë„ í´ë§ ì‹œì‘
    if(pvpMode){
        startPvpGamePolling();
    }
}

let pvpGamePollInterval = null;

function startPvpGamePolling(){
    if(pvpGamePollInterval) clearInterval(pvpGamePollInterval);
    
    // Clean up existing UI elements
    const oldPanel = document.getElementById('pvpOpponentProgress');
    if(oldPanel) oldPanel.remove();
    const oldBtn = document.getElementById('pvpForfeitBtn');
    if(oldBtn) oldBtn.remove();
    
    const progressPanel = document.createElement('div');
    progressPanel.id = 'pvpOpponentProgress';
    progressPanel.style.cssText = 'position:fixed; top:20px; left:50%; transform:translateX(-50%); background:white; padding:12px 16px; border-radius:12px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:9999; min-width:200px; font-size:13px;';
    progressPanel.innerHTML = `<div style="font-weight:700; margin-bottom:8px; text-align:center;">âš”ï¸ ì§„í–‰ë„</div><div id="pvpOpponentList"></div>`;
    document.body.appendChild(progressPanel);
    
    // Forfeit button at same position as reset button (bottom-right)
    const forfeitBtn = document.createElement('button');
    forfeitBtn.id = 'pvpForfeitBtn';
    forfeitBtn.className = 'floating-reset-btn';
    forfeitBtn.onclick = forfeitGame;
    forfeitBtn.style.cssText = 'position:fixed; bottom:30px; right:30px; z-index:10000; box-shadow:0 8px 20px rgba(0,0,0,0.2); font-size:15px; padding:12px 24px; background:#ef4444; color:white; border:none; border-radius:30px; cursor:pointer;';
    forfeitBtn.innerHTML = 'ğŸ³ï¸ ê¸°ê¶Œ';
    document.body.appendChild(forfeitBtn);
    
    pvpGamePollInterval = setInterval(async()=>{
        try {
            // Send my progress (clamped 0-100)
            const myProgress = Math.max(0, Math.min(100, Math.round((1 - (inversionCount(currentKeys()) / Math.max(1, initialInv))) * 100)));
            
            // Optimization: Only send if changed
            if(window.lastSentProgress === undefined || window.lastSentProgress !== myProgress){
                await fetch(`${API_BASE}/pvp.php`, {
                    method: 'POST',
                    headers: {'Content-Type':'application/x-www-form-urlencoded'},
                    body: new URLSearchParams({action:'update_progress', room_code:pvpRoomCode, player_id:userInfo.id, progress:myProgress})
                });
                window.lastSentProgress = myProgress;
            }
            
            // Get all players progress
            const res = await fetch(`${API_BASE}/pvp.php`, {
                method: 'POST',
                headers: {'Content-Type':'application/x-www-form-urlencoded'},
                body: new URLSearchParams({action:'status', room_code:pvpRoomCode})
            });
            const data = await res.json();
            if(data.success){
                const me = data.players.find(p => p.id === userInfo.id);
                const others = data.players.filter(p => p.id !== userInfo.id);
                
                const listEl = document.getElementById('pvpOpponentList');
                if(listEl){
                    // Self first
                    let html = `
                        <div style="margin-bottom:8px; padding-bottom:8px; border-bottom:1px solid #e2e8f0;">
                            <div style="display:flex; justify-content:space-between; margin-bottom:2px;">
                                <span style="font-weight:600;">ğŸ™‹ ${me?.name || userInfo.name}</span>
                                <span>${me?.finish_time ? 'âœ…ì™„ë£Œ' : (me?.progress||0)+'%'}</span>
                            </div>
                            <div style="background:#e2e8f0; height:8px; border-radius:4px; overflow:hidden;">
                                <div style="background:#3b82f6; height:100%; width:${me?.finish_time ? 100 : (me?.progress||0)}%; transition:width 0.3s;"></div>
                            </div>
                        </div>`;
                    
                    // Others
                    html += others.map(p => `
                        <div style="margin-bottom:6px;">
                            <div style="display:flex; justify-content:space-between; margin-bottom:2px;">
                                <span>${p.name}</span>
                                <span>${p.finish_time ? 'âœ…ì™„ë£Œ' : (p.progress||0)+'%'}</span>
                            </div>
                            <div style="background:#e2e8f0; height:6px; border-radius:3px; overflow:hidden;">
                                <div style="background:${p.finish_time ? '#22c55e' : 'var(--primary)'}; height:100%; width:${p.finish_time ? 100 : (p.progress||0)}%; transition:width 0.3s;"></div>
                            </div>
                        </div>
                    `).join('');
                    
                    listEl.innerHTML = html;
                }
                
                // Check if game finished - show result to ALL players immediately
                if(data.status === 'finished'){
                    clearInterval(pvpGamePollInterval);
                    clearInterval(timerId);
                    finished = true;
                    const panel = document.getElementById('pvpOpponentProgress');
                    if(panel) panel.remove();
                    const forfeitBtn = document.getElementById('pvpForfeitBtn');
                    if(forfeitBtn) forfeitBtn.remove();
                    showMultiplayerResult(data.players);
                }
            }
        } catch(e){}
    }, 1000);
}

function showMultiplayerResult(players){
    
    // Keep alive while viewing result
    startHeartbeat();
    
    // Clean up game UI first
    if(pvpGamePollInterval) clearInterval(pvpGamePollInterval);
    const panel = document.getElementById('pvpOpponentProgress');
    if(panel) panel.remove();
    const forfeitBtn = document.getElementById('pvpForfeitBtn');
    if(forfeitBtn) forfeitBtn.remove();
    
    // Hide default close button for PVP (we use custom 'í™•ì¸' button)
    const finishCloseBtn = document.getElementById('finishCloseBtn');
    if(finishCloseBtn) finishCloseBtn.style.display = 'none';
    
    // Ranking logic:
    // - Lower finish_time = better (faster completion)
    // - null = still playing - treat as Infinity (worst)
    // - 9999 = forfeit - also treat as Infinity (worst)
    // So: completed (1-9998 seconds) < forfeit/still playing (Infinity)
    const sorted = [...players].sort((a,b) => {
        let tA = (a.finish_time === null || a.finish_time >= 9999) ? Infinity : a.finish_time;
        let tB = (b.finish_time === null || b.finish_time >= 9999) ? Infinity : b.finish_time;
        return tA - tB;
    });
    
    // Find my data
    const myData = sorted.find(p => p.id === userInfo.id);
    const myIndex = sorted.findIndex(p => p.id === userInfo.id);
    const myRank = myIndex === -1 ? '-' : (myIndex + 1);
    
    // Winner logic for 1v1:
    const myFinishTime = myData?.finish_time;
    const iForfeited = myFinishTime !== null && myFinishTime >= 9999;
    const iFinished = myFinishTime !== null && myFinishTime < 9999;
    const iPlaying = myFinishTime === null;
    
    // Check opponent (for 1v1)
    const opponent = sorted.find(p => p.id !== userInfo.id);
    const opponentForfeited = opponent?.finish_time !== null && opponent?.finish_time >= 9999;
    const opponentFinished = opponent?.finish_time !== null && opponent?.finish_time < 9999;
    const opponentPlaying = opponent?.finish_time === null;
    
    
    // Determine winner
    let isWinner = false;
    let resultText = '';
    
    if(sorted.length === 2) { // 1v1
        // Simple logic: rank 1 = winner, rank 2 = loser
        // If I forfeited (9999), I definitely lose
        // If opponent forfeited, I definitely win
        if(iForfeited && opponentForfeited) {
            resultText = `<span style="color:#f59e0b; font-size:36px; font-weight:800;">ğŸ¤ ë¬´ìŠ¹ë¶€</span>`;
        } else if(iForfeited) {
            resultText = `<span style="color:#ef4444; font-size:36px; font-weight:800;">ğŸ˜¢ íŒ¨ë°°!</span>`;
        } else if(opponentForfeited) {
            isWinner = true;
            resultText = `<span style="color:#22c55e; font-size:36px; font-weight:800;">ğŸ† ìŠ¹ë¦¬!</span>`;
        } else {
            // Use ranking: whoever has lower finish_time wins
            // If both null, use index (first in sorted = winner)
            isWinner = myRank === 1;
            resultText = isWinner 
                ? `<span style="color:#22c55e; font-size:36px; font-weight:800;">ğŸ† ìŠ¹ë¦¬!</span>`
                : `<span style="color:#ef4444; font-size:36px; font-weight:800;">ğŸ˜¢ íŒ¨ë°°!</span>`;
        }
    } else {
        // Multiplayer - show rank
        if(iForfeited) {
            resultText = `<span style="color:#ef4444; font-size:36px; font-weight:800;">ğŸ³ï¸ ê¸°ê¶Œ</span>`;
        } else {
            isWinner = myRank === 1;
            const rankDisplay = (myRank === '-' || myRank === 0) ? '?' : myRank;
            resultText = isWinner 
                ? `<span style="color:#22c55e; font-size:36px; font-weight:800;">ğŸ† ìŠ¹ë¦¬!</span>`
                : `<span style="color:#ef4444; font-size:36px; font-weight:800;">ğŸ˜¢ ${rankDisplay}ë“±</span>`;
        }
    }
    
    // Display Time for MY record
    let myTimeDisplay = '-';
    if(iForfeited) {
        myTimeDisplay = 'ê¸°ê¶ŒíŒ¨';
    } else if(iFinished) {
        myTimeDisplay = myFinishTime + 'ì´ˆ';
    } else if(isWinner) {
        myTimeDisplay = 'ê¸°ê¶ŒìŠ¹';
    }
    
    let rankHtml = sorted.map((p, i) => {
        // Determine opponent status for display
        const pForfeited = p.finish_time !== null && p.finish_time >= 9999;
        const pFinished = p.finish_time !== null && p.finish_time < 9999;
        const pPlaying = p.finish_time === null;
        
        let timeDisplay = '';
        if(pForfeited) {
            timeDisplay = 'ğŸ³ï¸ê¸°ê¶Œ';
        } else if(pFinished) {
            timeDisplay = p.finish_time + 'ì´ˆ';
        } else if(pPlaying) {
            // Game has ended but this player didn't finish
            // In 1v1: if opponent forfeited, show ìŠ¹ë¦¬
            // In multiplayer: show ì‹¤íŒ¨
            if(sorted.length === 2) {
                const otherPlayer = sorted.find(op => op.id !== p.id);
                if(otherPlayer && otherPlayer.finish_time >= 9999) {
                    timeDisplay = 'ğŸ†ìŠ¹ë¦¬';
                } else {
                    timeDisplay = 'âŒì‹¤íŒ¨';
                }
            } else {
                // Multiplayer - player didn't finish, game ended
                timeDisplay = 'âŒì‹¤íŒ¨';
            }
        }
        
        let rankText = (i+1)+'ë“±';
        if(i===0) rankText = 'ğŸ¥‡';
        if(i===1) rankText = 'ğŸ¥ˆ';
        if(i===2) rankText = 'ğŸ¥‰';
        
        return `<div style="display:flex; justify-content:space-between; padding:8px; ${p.id === userInfo.id ? 'background:#f0f9ff; border-radius:6px;' : ''}">
            <span>${rankText} ${p.name}</span>
            <span style="font-weight:600;">${timeDisplay}</span>
        </div>`;
    }).join('');
    
    document.getElementById('finishModal').classList.remove('hidden');
    document.getElementById('finishMessage').innerHTML = `${resultText}<div id="pvpRankList" style="margin-top:16px; text-align:left; font-size:14px;">${rankHtml}</div>`;
    
    // Show close button as Return to PVP
    if(finishCloseBtn) {
        finishCloseBtn.style.display = 'block';
        finishCloseBtn.textContent = 'ëŒì•„ê°€ê¸°';
        finishCloseBtn.onclick = returnToPvpRoom;
    }
    document.getElementById('finishTimeVal').textContent = myTimeDisplay;
    
    // Set difficulty for PVP
    const modeLabelsResult = {'10':'í•˜ë‚¨ì','20':'ì¤‘ë‚¨ì','40':'ìƒë‚¨ì','80':'ì”¹ìƒë‚¨ì'};
    document.getElementById('finishDifficultyVal').textContent = modeLabelsResult[String(N)] || N + 'ê°œ';
    
    // Start result polling to update other players' records
    if(pvpResultPollInterval) clearInterval(pvpResultPollInterval);
    pvpResultPollInterval = setInterval(async () => {
        if(!pvpRoomCode) { clearInterval(pvpResultPollInterval); return; }
        try {
            const res = await fetch(`${API_BASE}/pvp.php`, {
                method: 'POST',
                headers: {'Content-Type':'application/x-www-form-urlencoded'},
                body: new URLSearchParams({action:'status', room_code:pvpRoomCode, player_id:userInfo.id})
            });
            const data = await res.json();
            if(data.success && data.players) {
                updateResultRanking(data.players);
            }
        } catch(e) {}
    }, 2000);
    
    // Record PVP result to server
    if(typeof isWinner !== 'undefined' && !window.isResultRecorded) {
        window.isResultRecorded = true;
        const result = isWinner ? 'win' : 'loss';
        fetch(`${API_BASE}/pvp.php`, {
            method: 'POST',
            headers: {'Content-Type':'application/x-www-form-urlencoded'},
            body: new URLSearchParams({action:'record_result', player_id:userInfo.id, result:result})
        }).then(() => {
            // Update local stats
            if(!userInfo.pvp_stats) userInfo.pvp_stats = {wins:0, losses:0};
            if(isWinner) userInfo.pvp_stats.wins++;
            else userInfo.pvp_stats.losses++;
            localStorage.setItem('questree_user', JSON.stringify(userInfo));
        }).catch(e => console.error('Failed to record result:', e));
    }
}

let pvpResultPollInterval = null;

function updateResultRanking(players) {
    const rankListEl = document.getElementById('pvpRankList');
    if(!rankListEl) return;
    
    const sorted = [...players].sort((a,b) => {
        let tA = (a.finish_time === null || a.finish_time >= 9999) ? Infinity : a.finish_time;
        let tB = (b.finish_time === null || b.finish_time >= 9999) ? Infinity : b.finish_time;
        return tA - tB;
    });
    
    let rankHtml = sorted.map((p, i) => {
        const pForfeited = p.finish_time !== null && p.finish_time >= 9999;
        const pFinished = p.finish_time !== null && p.finish_time < 9999;
        const pPlaying = p.finish_time === null;
        
        let timeDisplay = '';
        if(pForfeited) {
            timeDisplay = 'ğŸ³ï¸ê¸°ê¶Œ';
        } else if(pFinished) {
            timeDisplay = p.finish_time + 'ì´ˆ';
        } else if(pPlaying) {
            timeDisplay = 'â³ì§„í–‰ì¤‘';
        }
        
        let rankText = (i+1)+'ë“±';
        if(i===0) rankText = 'ğŸ¥‡';
        if(i===1) rankText = 'ğŸ¥ˆ';
        if(i===2) rankText = 'ğŸ¥‰';
        
        return `<div style="display:flex; justify-content:space-between; padding:8px; ${p.id === userInfo.id ? 'background:#f0f9ff; border-radius:6px;' : ''}">
            <span>${rankText} ${p.name}</span>
            <span style="font-weight:600;">${timeDisplay}</span>
        </div>`;
    }).join('');
    
    rankListEl.innerHTML = rankHtml;
}

window.returnToPvpRoom = async function(){
    if(pvpResultPollInterval) clearInterval(pvpResultPollInterval);
    document.getElementById('finishModal').classList.add('hidden');
    stopHeartbeat();
    
    // Set flag to ignore 'finished' status from server until it becomes 'waiting'
    window.ignoreFinishStatus = true;
    
    // Reset local game state (UI)
    resetAll();
    
    // Restore PVP specific UI
    const gameStatusPanel = document.getElementById('gameStatusPanel');
    const rankingBtnArea = document.getElementById('rankingBtnArea');
    if(gameStatusPanel) gameStatusPanel.classList.remove("active");
    if(rankingBtnArea) rankingBtnArea.classList.add("active"); 
    // Ensure card reset
    const card = document.getElementById('card');
    if(card) {
        card.classList.remove("game-active");
        card.style.transform = ''; // Clear inline styles
    }
    // Clear body classes just in case
    document.body.classList.remove('game-mode'); // If such class exists
    
    // If host, send reset signal to server
    if(pvpIsHost){
        try {
            await fetch(`${API_BASE}/pvp.php`, {
                method: 'POST',
                headers: {'Content-Type':'application/x-www-form-urlencoded'},
                body: new URLSearchParams({action:'reset', room_code:pvpRoomCode, host_id:userInfo.id})
            });
        } catch(e){}
    } else {
        // If guest, force unready
        try {
            await fetch(`${API_BASE}/pvp.php`, {
                method: 'POST',
                headers: {'Content-Type':'application/x-www-form-urlencoded'},
                body: new URLSearchParams({action:'ready', room_code:pvpRoomCode, player_id:userInfo.id, force:'false'})
            });
        } catch(e){}
    }
    
    // Reset ready state
    myReady = false;
    
    // Show WAITING ROOM again
    showWaitingRoom();
}

function showWaitingRoom(){
    const lobbyModal = document.getElementById('pvpLobbyModal');
    const waitingModal = document.getElementById('pvpWaitingModal');
    const roomCodeDisplay = document.getElementById('pvpRoomCodeDisplay');
    const waitingText = document.getElementById('pvpWaitingText');
    const startBtn = document.getElementById('pvpStartBtn');
    const readyBtn = document.getElementById('pvpReadyBtn');
    const countdownDisplay = document.getElementById('pvpCountdown');
    
    // Hide lobby, show waiting room
    if(lobbyModal) lobbyModal.classList.add('hidden');
    if(waitingModal) waitingModal.classList.remove('hidden');
    if(roomCodeDisplay) roomCodeDisplay.textContent = pvpRoomCode || '';
    if(countdownDisplay) countdownDisplay.style.display = 'none';
    
    if(pvpIsHost){
        if(startBtn) { startBtn.style.display = 'block'; startBtn.disabled = true; }
        if(readyBtn) readyBtn.style.display = 'none';
        if(waitingText) waitingText.textContent = 'í”Œë ˆì´ì–´ ëŒ€ê¸° ì¤‘...';
    } else {
        if(startBtn) startBtn.style.display = 'none';
        if(readyBtn) {
            readyBtn.style.display = 'block';
            readyBtn.textContent = 'âœ‹ ì¤€ë¹„';
            readyBtn.classList.remove('primary');
            readyBtn.classList.add('secondary');
        }
        if(waitingText) waitingText.textContent = 'í˜¸ìŠ¤íŠ¸ ëŒ€ê¸° ì¤‘...';
    }
    
    // Clear and restart polling with delay to let server sync
    if(pvpPollInterval) clearInterval(pvpPollInterval);
    pvpPollInterval = null;
    setTimeout(() => startPvpPolling(), 500);
}

// ê¸°ê¶Œ ì²˜ë¦¬
window.forfeitGame = async function(){
    if(!confirm('ì •ë§ ê¸°ê¶Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
    
    // Stop game
    finished = true;
    clearInterval(timerId);
    if(pvpGamePollInterval) clearInterval(pvpGamePollInterval);
    const panel = document.getElementById('pvpOpponentProgress');
    if(panel) panel.remove();
    const forfeitBtn = document.getElementById('pvpForfeitBtn');
    if(forfeitBtn) forfeitBtn.remove();
    
    // Send forfeit as 9999 seconds
    console.log('[FORFEIT] Sending forfeit for', userInfo.id, 'to room', pvpRoomCode);
    try {
        const resp = await fetch(`${API_BASE}/pvp.php`, {
            method: 'POST',
            headers: {'Content-Type':'application/x-www-form-urlencoded'},
            body: new URLSearchParams({action:'finish', room_code:pvpRoomCode, player_id:userInfo.id, time:9999})
        });
        const result = await resp.json();
        console.log('[FORFEIT] Server response:', result);
    } catch(e){ console.error('[FORFEIT] Error:', e); }
    
    // Reset and show result
    pollPvpResult(true); // Immediate check
}

// Heartbeat vars
let pvpHeartbeatInterval = null;

function startHeartbeat(){
    if(pvpHeartbeatInterval) clearInterval(pvpHeartbeatInterval);
    pvpHeartbeatInterval = setInterval(()=>{
        if(pvpRoomCode && userInfo.id){
            fetch(`${API_BASE}/pvp.php`, {
                method: 'POST',
                headers: {'Content-Type':'application/x-www-form-urlencoded'},
                body: new URLSearchParams({action:'status', room_code:pvpRoomCode, player_id:userInfo.id})
            }).catch(()=>{});
        }
    }, 3000);
}

function stopHeartbeat(){
    if(pvpHeartbeatInterval) clearInterval(pvpHeartbeatInterval);
    pvpHeartbeatInterval = null;
}

window.leavePvpRoom = async function(){
    if(pvpPollInterval) clearInterval(pvpPollInterval);
    stopHeartbeat();
    try {
        await fetch(`${API_BASE}/pvp.php`, {
            method: 'POST',
            headers: {'Content-Type':'application/x-www-form-urlencoded'},
            body: new URLSearchParams({action:'leave', room_code:pvpRoomCode, player_id:userInfo.id})
        });
    } catch(e){}
    pvpRoomCode = null;
    pvpMode = false;
    document.getElementById('pvpWaitingModal').classList.add('hidden');
    openPvpLobby();
}

// PVP ì™„ë£Œ ì „ì†¡ ë° ê²°ê³¼ í´ë§
async function sendPvpFinish(time){
    // Start heartbeat to prevent kick while waiting for others
    startHeartbeat();
    
    // Hide forfeit button, show spectating
    const panel = document.getElementById('pvpOpponentProgress');
    if(panel){
        const title = panel.querySelector('div');
        if(title) title.innerHTML = 'ğŸ‘€ ê´€ì „ ì¤‘';
        const forfeitBtn = document.getElementById('pvpForfeitBtn');
        if(forfeitBtn) forfeitBtn.style.display = 'none';
    }
    
    try {
        await fetch(`${API_BASE}/pvp.php`, {
            method: 'POST',
            headers: {'Content-Type':'application/x-www-form-urlencoded'},
            body: new URLSearchParams({action:'finish', room_code:pvpRoomCode, player_id:userInfo.id, time:time})
        });
    } catch(e){}
    pollPvpResult();
}

function pollPvpResult(forceShow = false){
    const poll = async()=>{
        try {
            const res = await fetch(`${API_BASE}/pvp.php`, {
                method: 'POST',
                headers: {'Content-Type':'application/x-www-form-urlencoded'},
                body: new URLSearchParams({action:'status', room_code:pvpRoomCode, player_id:userInfo.id}) 
            });
            const data = await res.json();
            
            // Check if *I* have finished status in the server
            const me = data.players?.find(p => p.id === userInfo.id);
            const myFinishCtx = me?.finish_time !== null;
            
            if(data.success && (data.status === 'finished' || myFinishCtx || forceShow)){
                if(window.pvpResultPollId) clearInterval(window.pvpResultPollId);
                showMultiplayerResult(data.players);
            } else if(!data.success && forceShow) {
                // If forced show but server says no success, likely room closed or error
                alert("ê²°ê³¼ ì¡°íšŒ ì‹¤íŒ¨: " + (data.message || "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜"));
            }
        } catch(e){
            // console.error(e);
            if(forceShow) alert("ì„œë²„ í†µì‹  ì˜¤ë¥˜: " + e);
        }
    };
    
    // Execute with slight delay to allow server file save
    setTimeout(() => {
        poll();
        // Then interval
        if(window.pvpResultPollId) clearInterval(window.pvpResultPollId);
        window.pvpResultPollId = setInterval(poll, 1000);
    }, 300);
}

function showPvpResult(data){
    const isWinner = (pvpIsHost && data.winner === 'host') || (!pvpIsHost && data.winner === 'guest');
    const myTime = pvpIsHost ? data.host_finish : data.guest_finish;
    const opponentTime = pvpIsHost ? data.guest_finish : data.host_finish;
    const opponentName = pvpIsHost ? data.guest_name : data.host_name;
    
    document.getElementById('finishModal').classList.remove('hidden');
    document.getElementById('finishMessage').innerHTML = isWinner 
        ? `<span style="color:#22c55e; font-size:28px;">ğŸ† ìŠ¹ë¦¬!</span><br><span style="font-size:16px;">vs ${opponentName}</span>`
        : `<span style="color:#ef4444; font-size:28px;">ğŸ˜¢ íŒ¨ë°°</span><br><span style="font-size:16px;">vs ${opponentName}</span>`;
    document.getElementById('finishTimeVal').textContent = `${myTime}ì´ˆ vs ${opponentTime}ì´ˆ`;
    
    pvpRoomCode = null;
    pvpMode = false;
}

// í˜ì´ì§€ ë‹«í ë•Œ ë°© ìë™ ë‚˜ê°€ê¸°
window.addEventListener('beforeunload', function() {
    if(typeof pvpRoomCode !== 'undefined' && pvpRoomCode && userInfo.id) {
        const data = new URLSearchParams({action:'leave', room_code:pvpRoomCode, player_id:userInfo.id});
        navigator.sendBeacon(`${API_BASE}/pvp.php`, data);
    }
});

// ë­í‚¹ íƒ­ ì „í™˜
let currentRankTab = 'solo';
window.switchRankTab = async function(tab) {
    currentRankTab = tab;
    const soloBtn = document.getElementById('rankTabSolo');
    const pvpBtn = document.getElementById('rankTabPvp');
    const subtitle = document.getElementById('rankingModalSubtitle');
    const rankList = document.getElementById('rankList');
    
    if(tab === 'solo') {
        soloBtn.style.background = '#0ea5e9';
        soloBtn.style.color = 'white';
        pvpBtn.style.background = '#e2e8f0';
        pvpBtn.style.color = '#64748b';
        // Use existing openRankingModal logic
        const modeKey = sizeSel.options[sizeSel.selectedIndex].text;
        const key = sizeSel.value;
        const modeNames = {'10':'í•˜ë‚¨ì','20':'ì¤‘ë‚¨ì','40':'ìƒë‚¨ì','80':'ì”¹ìƒë‚¨ì'};
        subtitle.textContent = modeNames[key] || modeKey;
        
        const ranks = await getRanks(key);
        if(ranks.length === 0){
            rankList.innerHTML = '<div style="text-align:center; padding:20px; color:#64748b;">ì•„ì§ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</div>';
        } else {
            let html = '';
            ranks.slice(0, 10).forEach((r, idx) => {
                const medal = idx === 0 ? 'ğŸ¥‡' : idx === 1 ? 'ğŸ¥ˆ' : idx === 2 ? 'ğŸ¥‰' : `${idx+1}`;
                html += `
                    <div style="display:flex; align-items:center; gap:12px; padding:10px; background:${idx<3?'#fef9c3':'#f8fafc'}; border-radius:8px; margin-bottom:6px;">
                        <span style="font-size:18px; width:28px; text-align:center;">${medal}</span>
                        <span style="flex:1; font-weight:600;">${escapeHtml(r.name)}</span>
                        <span style="font-size:14px; font-weight:700; color:#0ea5e9;">${Number(r.time).toFixed(2)}ì´ˆ</span>
                    </div>
                `;
            });
            rankList.innerHTML = html;
        }
    } else {
        pvpBtn.style.background = '#0ea5e9';
        pvpBtn.style.color = 'white';
        soloBtn.style.background = '#e2e8f0';
        soloBtn.style.color = '#64748b';
        subtitle.textContent = 'PVP ìŠ¹ìˆ˜ ê¸°ì¤€';
        await loadPvpRanking();
    }
};

async function loadPvpRanking() {
    const rankList = document.getElementById('rankList');
    rankList.innerHTML = '<div style="text-align:center; padding:20px; color:#64748b;">ë¡œë”© ì¤‘...</div>';
    
    try {
        const res = await fetch(`${API_BASE}/pvp.php`, {
            method: 'POST',
            headers: {'Content-Type':'application/x-www-form-urlencoded'},
            body: new URLSearchParams({action:'pvp_ranking'})
        });
        const data = await res.json();
        
        if(data.success && data.ranking && data.ranking.length > 0) {
            let html = '';
            data.ranking.forEach((p, i) => {
                const medal = i === 0 ? 'ğŸ¥‡' : i === 1 ? 'ğŸ¥ˆ' : i === 2 ? 'ğŸ¥‰' : `${i+1}`;
                const total = p.wins + p.losses;
                const rate = total > 0 ? Math.round((p.wins / total) * 100) : 0;
                html += `
                    <div style="display:flex; align-items:center; gap:12px; padding:10px; background:${i<3?'#fef9c3':'#f8fafc'}; border-radius:8px; margin-bottom:8px;">
                        <span style="font-size:20px; width:30px; text-align:center;">${medal}</span>
                        <span style="flex:1; font-weight:600;">${p.name}</span>
                        <span style="font-size:13px; color:#22c55e; font-weight:700;">${p.wins}ìŠ¹</span>
                        <span style="font-size:13px; color:#ef4444;">${p.losses}íŒ¨</span>
                        <span style="font-size:12px; color:#64748b;">(${rate}%)</span>
                    </div>
                `;
            });
            rankList.innerHTML = html;
        } else {
            rankList.innerHTML = '<div style="text-align:center; padding:20px; color:#64748b;">ì•„ì§ PVP ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</div>';
        }
    } catch(e) {
        rankList.innerHTML = '<div style="text-align:center; padding:20px; color:#ef4444;">ë­í‚¹ ë¡œë“œ ì‹¤íŒ¨</div>';
    }
}

// ì´ˆê¸° ì‹¤í–‰ ì‹œ
resetAll();
</script>
</body>
</html>
